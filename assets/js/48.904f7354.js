(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{413:function(v,_,o){"use strict";o.r(_);var e=o(0),l=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"threadlocal有哪些使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal有哪些使用场景"}},[v._v("#")]),v._v(" ThreadLocal有哪些使用场景")]),v._v(" "),_("p",[v._v("ThreadLocal是一种多线程隔离机制，通过多线程环境下对共享变量的副本存储，解决了线程安全问题，避免了多线程竞争加锁的开销。其使用场景包括：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("线程的上下文传递")]),v._v(" "),_("ul",[_("li",[v._v("在处理请求的过程中保持用户特定的数据（如用户的登录信息）。通过 "),_("code",[v._v("ThreadLocal")]),v._v(" 可以方便地在同一个线程内的不同方法调用之间共享这些数据，而不用担心线程安全问题。")])])]),v._v(" "),_("li",[_("p",[v._v("数据库连接管理")]),v._v(" "),_("ul",[_("li",[v._v("在多线程应用中，每个线程可以使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 来独立管理自己的数据库连接，避免线程之间的竞争与冲突。如mybatis的sqlsession")])])]),v._v(" "),_("li",[_("p",[v._v("事务管理等")]),v._v(" "),_("ul",[_("li",[v._v("使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 可以让每个线程拥有独立的事务上下文，保证事务的隔离性。Spring 的 "),_("code",[v._v("TransactionSynchronizationManager")]),v._v(" 就使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 来存储当前线程的事务资源（如数据库连接）。")])])])]),v._v(" "),_("p",[v._v("在使用ThreadLocall时，需要注意避免内存泄漏的问题。")]),v._v(" "),_("h1",{attrs:{id:"java线程的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java线程的生命周期"}},[v._v("#")]),v._v(" Java线程的生命周期")]),v._v(" "),_("p",[v._v("Java线程的生命周期包括6种状态（定义在"),_("code",[v._v("Thread.State")]),v._v("枚举中）：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("NEW（新建状态）")]),v._v("：\n"),_("ul",[_("li",[v._v("线程被创建但尚未启动。此时线程对象已经存在，但还没有调用"),_("code",[v._v("start()")]),v._v("方法。")])])]),v._v(" "),_("li",[_("strong",[v._v("RUNNABLE（可运行状态）")]),v._v("：\n"),_("ul",[_("li",[v._v("一旦调用了线程对象的 "),_("code",[v._v("start()")]),v._v(" 方法，线程就进入了 "),_("code",[v._v("RUNNABLE")]),v._v(" 状态。此时线程可能正在Java虚拟机中运行，也可能是在等待操作系统的调度来获取CPU时间片。在操作系统层面，"),_("code",[v._v("RUNNABLE")]),v._v("状态对应"),_("code",[v._v("RUNNING")]),v._v("（正在运行）和"),_("code",[v._v("READY")]),v._v("（准备运行）两种子状态。")])])]),v._v(" "),_("li",[_("strong",[v._v("BLOCKED（阻塞状态）")]),v._v("：\n"),_("ul",[_("li",[v._v("如果一个线程试图获取一个已经被其他线程持有的synchronized锁（即进入同步块或方法），那么该线程将进入 "),_("code",[v._v("BLOCKED")]),v._v(" 状态。只有当前持有锁的线程释放了锁，这个线程才能继续进行。")])])]),v._v(" "),_("li",[_("strong",[v._v("WAITING（等待状态）")]),v._v("：\n"),_("ul",[_("li",[v._v("线程进入等待状态，直到被其他线程显式唤醒。线程可以通过三种方法进入"),_("code",[v._v("WAITING")]),v._v("状态：\n"),_("ul",[_("li",[_("code",[v._v("Object.wait()")]),v._v("：等待其他线程调用"),_("code",[v._v("notify()")]),v._v("或"),_("code",[v._v("notifyAll()")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("Thread.join()")]),v._v("：等待目标线程执行完毕。")]),v._v(" "),_("li",[_("code",[v._v("LockSupport.park()")]),v._v("：暂停当前线程。")])])])])]),v._v(" "),_("li",[_("strong",[v._v("TIMED_WAITING（超时等待状态）")]),v._v("：\n"),_("ul",[_("li",[v._v("线程进入等待状态，但会在指定的时间后自动唤醒。线程可以通过四种带有超时时间的方法进入"),_("code",[v._v("TIMED_WAITING")]),v._v("状态：\n"),_("ul",[_("li",[_("code",[v._v("Thread.sleep(long millis)")]),v._v("：睡眠指定时间。")]),v._v(" "),_("li",[_("code",[v._v("Object.wait(long timeout)")]),v._v("：等待指定时间。")]),v._v(" "),_("li",[_("code",[v._v("Thread.join(long millis)")]),v._v("：等待目标线程指定时间。")]),v._v(" "),_("li",[_("code",[v._v("LockSupport.parkNanos(long nanos)")]),v._v("：暂停当前线程指定时间。")])])])])]),v._v(" "),_("li",[_("strong",[v._v("TERMINATED（终止状态）")]),v._v("：\n"),_("ul",[_("li",[v._v("线程执行完毕或因为异常退出，进入终止状态。此时线程的生命周期结束。")])])])]),v._v(" "),_("h1",{attrs:{id:"线程池如何知道线程任务的执行完成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程池如何知道线程任务的执行完成"}},[v._v("#")]),v._v(" 线程池如何知道线程任务的执行完成")]),v._v(" "),_("ol",[_("li",[v._v("线程池的isTerminated()\n"),_("ul",[_("li",[v._v("使用isTerminated()方法可以检查线程池是否已经完全终止，但需要先调用"),_("code",[v._v("shutdown()")]),v._v("方法。通常情况下，线程池不会随意关闭，因此"),_("code",[v._v("isTerminated()")]),v._v("的使用场景有限。")])])]),v._v(" "),_("li",[v._v("使用Future对象\n"),_("ul",[_("li",[v._v("Future可以判断单个任务的完成状态。通过调用线程池的"),_("code",[v._v("submit()")]),v._v("方法提交任务时，会返回一个"),_("code",[v._v("Future")]),v._v("对象，而"),_("code",[v._v("Future")]),v._v("的"),_("code",[v._v("isDone()")]),v._v("方法，可以非阻塞地检查任务是否完成。或者调用Future的get()方法可以阻塞当前线程，直到任务完成并返回结果或者抛出异常。")])])]),v._v(" "),_("li",[v._v("CountDownLatch：\n"),_("ul",[_("li",[v._v("使用 "),_("code",[v._v("CountDownLatch")]),v._v("同步工具，适合用于多个任务的同步，可以在开始时设置一个初始值，任务完成后调用 "),_("code",[v._v("countDown()")]),v._v(" 方法把计数器减一，主线程通过 "),_("code",[v._v("await()")]),v._v(" 等待计数器归零，表示任务完成。")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);