(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{416:function(a,t,v){"use strict";v.r(t);var s=v(0),_=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"类的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期"}},[a._v("#")]),a._v(" 类的生命周期")]),a._v(" "),t("p",[a._v("加载")]),a._v(" "),t("p",[a._v("验证")]),a._v(" "),t("p",[a._v("准备：给静态变量默认值、final初始值")]),a._v(" "),t("p",[a._v("解析")]),a._v(" "),t("p",[a._v("初始化")]),a._v(" "),t("h2",{attrs:{id:"什么是类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是类加载器"}},[a._v("#")]),a._v(" 什么是类加载器")]),a._v(" "),t("p",[a._v("启动类加载器（C++、jdk9后java）")]),a._v(" "),t("p",[a._v("扩展类加载器、平台类加载器（jdk9）")]),a._v(" "),t("p",[a._v("应用程序类加载器")]),a._v(" "),t("p",[a._v("自定义类加载器：重写findclass方法")]),a._v(" "),t("h2",{attrs:{id:"什么是双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是双亲委派机制"}},[a._v("#")]),a._v(" 什么是双亲委派机制")]),a._v(" "),t("p",[a._v("每一个类加载器都有一个父类加载器，形成一个层级结构")]),a._v(" "),t("p",[a._v("当一个类加载器接收到加载类的任务后，会查找这个类是否被加载过，没有则向上投递，直到启动类加载器，这个就是向上查找的过程，")]),a._v(" "),t("p",[a._v("如果启动类加载器也没有加载过，就检查该类是否在自己的加载路径上，没有则向下投递给下一个加载器加载，这个就是向下加载。这两个过程就是双亲委派机制，如果没有加载器能够加载，就抛出ClassNotFoundException")]),a._v(" "),t("p",[a._v("双亲委派机制的作用")]),a._v(" "),t("p",[a._v("​\t保证类加载的安全，如果要加载一个同名的String类，都会交给启动类加载，发现被加载过了就不会再加载，")]),a._v(" "),t("p",[a._v("​\t避免类的重复加载")]),a._v(" "),t("h2",{attrs:{id:"打破双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打破双亲委派机制"}},[a._v("#")]),a._v(" 打破双亲委派机制")]),a._v(" "),t("p",[a._v("打破双亲委派机制唯一方法是自定义类加载器中重写loadClass方法")]),a._v(" "),t("h2",{attrs:{id:"如何判断堆上的对象有没有被引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何判断堆上的对象有没有被引用"}},[a._v("#")]),a._v(" 如何判断堆上的对象有没有被引用")]),a._v(" "),t("p",[a._v("引用计数法")]),a._v(" "),t("ul",[t("li",[a._v("为每一个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1，存在循环依赖问题，所以java没有使用这种方法")])]),a._v(" "),t("p",[a._v("可达性分析算法")]),a._v(" "),t("ul",[t("li",[a._v("java使用的可达性分析算法来判断对象是否可以被回收，可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象")]),a._v(" "),t("li",[a._v("可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可回收，最常见的GC Root对象会引用栈上的局部变量和静态变量导致对象不可回收。")]),a._v(" "),t("li",[a._v("哪些对象被称之为GC Root对象呢？\n"),t("strong",[a._v("线程Thread对象，引用线程栈帧中的方法参数、局部变量等。")]),a._v(" "),t("strong",[a._v("系统类加载器加载的java.lang.Class对象，引用类中的静态变量。")]),a._v("\n监视器对象，用来保存同步锁synchronized关键字持有的对象。\n本地方法调用时使用的全局对象。")])]),a._v(" "),t("h2",{attrs:{id:"jvm的内存模型及其分区-详细每个分区放什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm的内存模型及其分区-详细每个分区放什么"}},[a._v("#")]),a._v(" JVM的内存模型及其分区（详细每个分区放什么）")]),a._v(" "),t("h2",{attrs:{id:"堆里面的分区有什么-说说他们的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆里面的分区有什么-说说他们的特点"}},[a._v("#")]),a._v(" 堆里面的分区有什么，说说他们的特点")]),a._v(" "),t("p",[a._v("Eden、from、to")]),a._v(" "),t("h2",{attrs:{id:"gc算法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc算法有哪些"}},[a._v("#")]),a._v(" GC算法有哪些")]),a._v(" "),t("p",[a._v("引用计算、标记清除、标记压缩、复制算法")]),a._v(" "),t("h2",{attrs:{id:"轻gc和重gc在什么时候发生"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#轻gc和重gc在什么时候发生"}},[a._v("#")]),a._v(" 轻GC和重GC在什么时候发生")]),a._v(" "),t("h2",{attrs:{id:"jdk9将string底层实现char-改为byte"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk9将string底层实现char-改为byte"}},[a._v("#")]),a._v(" JDK9将String底层实现char[]改为byte[]")]),a._v(" "),t("p",[a._v("并没有将String底层实现char[]改为byte[]，而是引入了compact string的优化，减少string的内存消耗")]),a._v(" "),t("p",[a._v("java字符串在内部是由char[]来表示，jdk内部使用UTF-16意味着每个char由两个字节组成，如果一个字符串只包含一个英文字符/ASCII字符，只需要一个字节就可以表示，意味着字符串实际存储空间比需要存储的空间多一倍，")]),a._v(" "),t("p",[a._v("因此，jdk9引入compact string的优化，将char[]改为byte[]，只有存储非ASCII字符才会使用char[]，纯ASCII字符会存储在byte[]，从而节省一半空间")]),a._v(" "),t("p",[a._v("这个优化是在编译器和运行时环境实现的。透明的，使用jvm参数-xx: UseCompressedStrings")]),a._v(" "),t("h2",{attrs:{id:"对象在堆中的-内存布局-⭐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象在堆中的-内存布局-⭐"}},[a._v("#")]),a._v(" 对象在堆中的=="),t("strong",[a._v("内存布局")]),a._v("==⭐")]),a._v(" "),t("h2",{attrs:{id:"jvm工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm工具"}},[a._v("#")]),a._v(" JVM工具")]),a._v(" "),t("h3",{attrs:{id:"jvis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvis"}},[a._v("#")]),a._v(" jvis")])])}),[],!1,null,null,null);t.default=_.exports}}]);