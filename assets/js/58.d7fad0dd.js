(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{447:function(s,t,e){"use strict";e.r(t);var a=e(0),r=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("使用Redis+Token解决了在集群模式下的Session共享问题，使用拦截器实现用户的登录校验和权限刷新")]),s._v(" "),t("h2",{attrs:{id:"为什么使用redis-token来代替session"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用redis-token来代替session"}},[s._v("#")]),s._v(" 为什么使用Redis+Token来代替session")]),s._v(" "),t("p",[s._v("由于项目模拟了tomcat集群，用户的请求可能被不同的服务器处理。session是存储在单个服务器的内存中，其他服务器无法访问该Session，导致用户状态丢失，而如果使用服务器间的Session复制，会有延迟，导致数据的不一致，而且Session的复制会占用额内存，影响服务器的性能。")]),s._v(" "),t("p",[s._v("使用Redis+Token可以根据Token为key将用户信息存储在Redis中，所有服务器都可以共享Redis中的用户信息，从而实现SSO。")]),s._v(" "),t("h2",{attrs:{id:"为什么使用redis-token而不用jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用redis-token而不用jwt"}},[s._v("#")]),s._v(" 为什么使用Redis+Token而不用JWT")]),s._v(" "),t("p",[s._v("Redis+Token是有状态，用随机的UUID生成Token作为Key，依赖Redis存储用户信息，选择Redis+Token可以在用户登出或者有异常行为时，主动删除Redis中的Token来结束会话")]),s._v(" "),t("p",[s._v("不用JWT主要是因为JWT无法提前失效，只能将其加入Redis的黑名单中，在拦截器中拦截，但是也会违背JWT无状态的特性；而且JWT无法续期，我们的项目主要是用户在每次访问时会续期，如果用JWT，续期需要重新生成JWT，会导致有过多的JWT，增加管理负担；而且JWT通常UUID大，会增加网络传输负担。")]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("通过Redis缓存空数据解决了缓存穿透问题，结合动态TTL机制防止缓存雪崩，缓存失效时使用互斥锁解决缓存击穿")]),s._v(" "),t("h2",{attrs:{id:"缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[s._v("#")]),s._v(" 缓存穿透")]),s._v(" "),t("p",[t("RouterLink",{attrs:{to:"/04.面试/#_1-什么是缓存穿透，怎么解决（null、布隆、降级保底）"}},[s._v("缓存穿透是")])],1),s._v(" "),t("h2",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[s._v("#")]),s._v(" 缓存雪崩")]),s._v(" "),t("h3",{attrs:{id:"布隆过滤器的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器的实现原理"}},[s._v("#")]),s._v(" 布隆过滤器的实现原理")]),s._v(" "),t("h2",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[s._v("#")]),s._v(" 缓存击穿")]),s._v(" "),t("p",[s._v("解决方法：互斥锁从数据库中获取数据、使用逻辑过期，数据过期通过异步获取数据，并发线程返回旧数据。")]),s._v(" "),t("h3",{attrs:{id:"为什么用逻辑过期而不用互斥锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么用逻辑过期而不用互斥锁"}},[s._v("#")]),s._v(" 为什么用逻辑过期而不用互斥锁")]),s._v(" "),t("p",[s._v("因为我们缓存的数据是商户的信息，一致性要求不高，使用逻辑过期可以保留redis中缓存的数据，数据过期时开启一个异步线程从数据库中获取数据更新，而并发线程可以直接返回缓存的旧数据。其实也可以使用互斥锁，因为从数据库获取商户信息的过程也不费时间，不会导致可用性降低，如果数据重建过程费时间才需要根据一致性要求决定选择方案。")]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("使用Redis实现全局唯一ID生成，并通过乐观锁（CAS机制）进行库存控制，解决超卖问题。")]),s._v(" "),t("h2",{attrs:{id:"为什么使用redis生成唯一id-为什么不选择数据库子自增id、雪花算法呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用redis生成唯一id-为什么不选择数据库子自增id、雪花算法呢"}},[s._v("#")]),s._v(" 为什么使用Redis生成唯一ID，为什么不选择数据库子自增ID、雪花算法呢")]),s._v(" "),t("p",[s._v("因为Redis是基于内存的，适合高并发，可以保证高可用、高性能、唯一性，\n而数据库性能瓶颈明显，且分库分表时维护自增ID复杂度高，\n雪花算法需要考虑时钟回拨（回拨时id会归零），而且不同机器之间系统时钟可能存在微小偏差，可能导致id不是有序的")]),s._v(" "),t("h2",{attrs:{id:"cas机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas机制"}},[s._v("#")]),s._v(" CAS机制")]),s._v(" "),t("h3",{attrs:{id:"高并发下cas失败率高-如何优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高并发下cas失败率高-如何优化"}},[s._v("#")]),s._v(" 高并发下CAS失败率高，如何优化？")])])}),[],!1,null,null,null);t.default=r.exports}}]);