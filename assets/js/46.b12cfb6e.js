(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{414:function(a,e,r){"use strict";r.r(e);var l=r(0),v=Object(l.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"谈谈你对threadlocal的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对threadlocal的理解"}},[a._v("#")]),a._v(" 谈谈你对ThreadLocal的理解")]),a._v(" "),e("p",[a._v("ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享")]),a._v(" "),e("h2",{attrs:{id:"threadlocal的底层原理实现吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal的底层原理实现吗"}},[a._v("#")]),a._v(" ThreadLocal的底层原理实现吗？")]),a._v(" "),e("p",[a._v("在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象")]),a._v(" "),e("p",[a._v("当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中")]),a._v(" "),e("p",[a._v("当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值")]),a._v(" "),e("p",[a._v("当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值")]),a._v(" "),e("h2",{attrs:{id:"threadlocal会导致内存溢出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal会导致内存溢出"}},[a._v("#")]),a._v(" "),e("a",{attrs:{href:"https://www.bilibili.com/video/BV1FRdyYgEH9",target:"_blank",rel:"noopener noreferrer"}},[a._v("ThreadLocal会导致内存溢出"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("ThreadLocal 如果使用不当，确实可能导致内存泄漏，核心原因是 "),e("strong",[a._v("ThreadLocalMap 的 key 是弱引用，而 value 是强引用")]),a._v("，加上线程复用（如线程池），无效的 Entry 无法被及时清理。")]),a._v(" "),e("p",[a._v("ThreadLocal 的数据存储在 线程的 ThreadLocalMap 中，key 是 ThreadLocal 对象本身， 它是弱引用，会被 GC 回收变为 null，但 Value 仍被 Entry 强引用，导致无法回收。")]),a._v(" "),e("p",[a._v("当线程一直存在不被清除时，比如线程池复用时，ThreadLocalMap 会一直存在")]),a._v(" "),e("p",[a._v("ThreadLocal有两种情况导致OOM：")]),a._v(" "),e("p",[a._v("当 ThreadLocal 是局部变量，用完被清除，失去强引用，key 因弱引用被 GC 回收变为null，而value会一直存在导致OOM。\n当ThreadLocal 是静态变量。虽然 key 不会被回收（静态变量是强引用），但如果线程复用时不调用 "),e("code",[a._v("remove()")]),a._v("，多次 "),e("code",[a._v("set()")]),a._v(" 会导致旧 value 无法释放（例如线程池任务中重复使用同一个 ThreadLocal）。")]),a._v(" "),e("p",[a._v("解决方法：")]),a._v(" "),e("p",[a._v("threadLocalMap有清除机制，会在调用set() / get() 时自动清除key为null的数据。\n但是使用ThreadLocal 时通常把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。")]),a._v(" "),e("h2",{attrs:{id:"threadlocal有哪些使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal有哪些使用场景"}},[a._v("#")]),a._v(" ThreadLocal有哪些使用场景")]),a._v(" "),e("p",[a._v("ThreadLocal是一种多线程隔离机制，通过多线程环境下对共享变量的副本存储，解决了线程安全问题，避免了多线程竞争加锁的开销。其使用场景包括：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("线程的上下文传递")]),a._v(" "),e("ul",[e("li",[a._v("在处理请求的过程中保持用户特定的数据（如用户的登录信息）。通过 "),e("code",[a._v("ThreadLocal")]),a._v(" 可以方便地在同一个线程内的不同方法调用之间共享这些数据，而不用担心线程安全问题。")])])]),a._v(" "),e("li",[e("p",[a._v("数据库连接管理")]),a._v(" "),e("ul",[e("li",[a._v("在多线程应用中，每个线程可以使用 "),e("code",[a._v("ThreadLocal")]),a._v(" 来独立管理自己的数据库连接，避免线程之间的竞争与冲突。如mybatis的sqlsession")])])]),a._v(" "),e("li",[e("p",[a._v("事务管理等")]),a._v(" "),e("ul",[e("li",[a._v("使用 "),e("code",[a._v("ThreadLocal")]),a._v(" 可以让每个线程拥有独立的事务上下文，保证事务的隔离性。Spring 的 "),e("code",[a._v("TransactionSynchronizationManager")]),a._v(" 就使用 "),e("code",[a._v("ThreadLocal")]),a._v(" 来存储当前线程的事务资源（如数据库连接）。")])])])]),a._v(" "),e("p",[a._v("在使用ThreadLocall时，需要注意避免内存泄漏的问题。")]),a._v(" "),e("h2",{attrs:{id:"保证线程安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#保证线程安全"}},[a._v("#")]),a._v(" 保证线程安全")]),a._v(" "),e("ul",[e("li",[a._v("在方法内使用，局部变量则是线程安全的")]),a._v(" "),e("li",[a._v("使用线程安全的ArrayList和LinkedList")])])])}),[],!1,null,null,null);e.default=v.exports}}]);