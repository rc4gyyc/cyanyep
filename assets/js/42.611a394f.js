(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{409:function(a,v,t){"use strict";t.r(v);var r=t(0),J=Object(r.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"jdk、jre、jvm之间的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jdk、jre、jvm之间的区别"}},[a._v("#")]),a._v(" JDK、JRE、JVM之间的区别")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("JDK(Java SE Development Kit)是 java 开发工具包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java运行时环境JRE、Java编译器，以及常用的Java类库等")])]),a._v(" "),v("li",[v("p",[a._v("JRE(Java Runtime Environment) ，Java运行环境，用于运行Java的字节码文件，JRE中包括了 JVM以及JVM工作所需要的类库，只需要安装JRE来运行Java程序，而程序开发者必须安装JDK来编译、调试程序。")])]),a._v(" "),v("li",[v("p",[a._v("JVM(Java Virtual Mechinal)，Java虚拟机，是一个运行在计算机上的程序，负责运行字节码文件，它是整个java实现跨平台的最核心的部分。")])]),a._v(" "),v("li",[v("p",[a._v("如果我们要开发Java程序，那就需要JDK来编译Java源文件。 如果我们只想运行已经编译好的Java字节码文件，也就是.class文件，那么就只需要JRE。 JDK中包含了JRE，JRE中包含了JVM。 另外，JVM在执行Java字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令是有可能 不一样的，所以就导致不同操作系统上的JVM是不一样的，所以我们在安装JDK时需要选择操作系统。 另外，JVM是用来执行Java字节码的，所以编译之后是Java字节码，那就都能在JVM上运行，比如Apache Groovy, Scala and Kotlin 等等。")])])]),a._v(" "),v("h1",{attrs:{id:"为何jdk9要将string底层实现由char-改成byte"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为何jdk9要将string底层实现由char-改成byte"}},[a._v("#")]),a._v(" 为何JDK9要将String底层实现由char[]改成byte[]?")]),a._v(" "),v("p",[a._v("JDK 9并没有将String的底层实现由char [] 改成byte[]，而是在 JDK 9中，引入了Compact Strings的优化，优化的目的是减少String对象的内存消耗。")]),a._v(" "),v("p",[a._v("jdk9中字符串由char[]数组来存储该字符串的所有字符，且内部采用utf-16编码，每个字符占用两个字符，但是如果字符串只包含英文字符或者ASCII字符，这些只需要一个字符就可以存储，这意味着字符串实际存储的空间比需要的空间多一倍\t。引入了Compact String优化，String的底层实现由char[]中改为byte[],只在存储非ASCII字符时使用char[]，对于纯ASCII字符就会存储再byte[]中，从而节省一半的内存空间。这个优化是在编译器和运行时实现，对开发者透明，只需通过虚拟机参数"),v("code",[a._v("-XX:+UseCompressedstrings")]),a._v("控制是否优化。")]),a._v(" "),v("h2",{attrs:{id:"java反射的优、缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java反射的优、缺点"}},[a._v("#")]),a._v(" Java反射的优、缺点")]),a._v(" "),v("p",[a._v("优点")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("增加程序的灵活性，可以在运行的过程中动态对类进行修改和操作")])]),a._v(" "),v("li",[v("p",[a._v("提高代码的复用率，比如动态代理，就是用到了反射来实现")])]),a._v(" "),v("li",[v("p",[a._v("可以在运行时轻松获取任意一个类的方法、属性，并且还能通过反射进行动态调用")])])]),a._v(" "),v("p",[a._v("缺点")]),a._v(" "),v("ul",[v("li",[a._v("反射会涉及到动态类型的解析，所以VM无法对这些代码进行优化，导致性能要比非反射调用更低")]),a._v(" "),v("li",[a._v("使用反射以后，代码的可读性会下降")]),a._v(" "),v("li",[a._v("反射可以绕过一些限制访问的属性或者方法，可能会导致破坏了代码本身的抽象性")])])])}),[],!1,null,null,null);v.default=J.exports}}]);