(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{466:function(e,r,n){"use strict";n.r(r);var a=n(1),t=Object(a.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("使用RabbitMQ来完成异步任务")]),e._v(" "),r("p",[e._v("项目中的秒杀下单业务是通过java的阻塞队列或者redis的stream消息队列实现异步处理订单的，")]),e._v(" "),r("p",[e._v("但是java的阻塞队列会有内存限制，服务器宕机等风险")]),e._v(" "),r("h2",{attrs:{id:"配置mq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#配置mq"}},[e._v("#")]),e._v(" 配置MQ")]),e._v(" "),r("p",[e._v("1）添加依赖：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("\x3c!--AMQP依赖，包含RabbitMQ--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n")])])]),r("p",[e._v("2）配置MQ地址：")]),e._v(" "),r("div",{staticClass:"language-YAML extra-class"},[r("pre",{pre:!0,attrs:{class:"language-yaml"}},[r("code",[r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("spring")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("rabbitmq")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("host")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 192.168.10.130 "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 你的虚拟机IP")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("port")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("5672")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 端口")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("virtual-host")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" /cyan "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 虚拟主机")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("username")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" cyan "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 用户名")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("password")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("123456")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 密码")]),e._v("\n")])])]),r("p",[e._v("在Virtual Hosts 中创建一个项目专用的virtual host：/cyan")]),e._v(" "),r("h2",{attrs:{id:"接收消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接收消息"}},[e._v("#")]),e._v(" 接收消息")]),e._v(" "),r("p",[e._v("定义一个消息监听类：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('package com.hmdp.listener;\n\nimport com.hmdp.entity.VoucherOrder;\nimport com.hmdp.service.IVoucherOrderService;\nimport lombok.RequiredArgsConstructor;\nimport org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.amqp.rabbit.annotation.Exchange;\nimport org.springframework.amqp.rabbit.annotation.Queue;\nimport org.springframework.amqp.rabbit.annotation.QueueBinding;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n@Component\n@RequiredArgsConstructor\npublic class VoucherOrderListener {\n    private final IVoucherOrderService voucherOrderService;\n    private final RedissonClient redissonClient;\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = "seckill.queue", durable = "true"),\n            exchange = @Exchange(name = "seckill.direct"),\n            key = "seckill.success"\n    ))\n    public void listenOrderMessage(VoucherOrder voucherOrder){\n        handleVoucherOrder(voucherOrder);\n\n    }\n    private void handleVoucherOrder(VoucherOrder voucherOrder) {\n        //1.获取用户\n        Long userId = voucherOrder.getUserId();\n        // 2.创建锁对象\n        RLock redisLock = redissonClient.getLock("lock:order:" + userId);\n        // 3.尝试获取锁\n        boolean isLock = redisLock.tryLock();\n        // 4.判断是否获得锁成功\n        if (!isLock) {\n            // 获取锁失败，直接返回失败或者重试\n//            log.error("不允许重复下单！");\n            return;\n        }\n        try {\n            voucherOrderService.createVoucherOrder(voucherOrder);\n        } finally {\n            // 释放锁\n            redisLock.unlock();\n        }\n    }\n}\n\n')])])]),r("h2",{attrs:{id:"发送消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发送消息"}},[e._v("#")]),e._v(" 发送消息")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('rabbitTemplate.convertAndSend("seckill.direct", "seckill.success", voucherOrder);\n')])])]),r("p",[e._v("为了防止消息过多导致MQ消息积压而丢失消息，开启MQ的lazy模式")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('@RabbitListener(bindings = @QueueBinding(\n        value = @Queue(name = "seckill.queue", durable = "true"),\n        exchange = @Exchange(name = "seckill.direct"),\n        arguments = @Argument(name = "x-queue-mode", value = "lazy"),\n        key = "seckill.success"\n))\n')])])]),r("h2",{attrs:{id:"抛出异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抛出异常"}},[e._v("#")]),e._v(" 抛出异常")]),e._v(" "),r("p",[e._v("故意抛出异常查看是否能处理正常")]),e._v(" "),r("p",[e._v("发现抛出异常回滚后，MQ检测到异常，但会不断尝试重试进行消费")]),e._v(" "),r("h3",{attrs:{id:"设置重试上限和重试次数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设置重试上限和重试次数"}},[e._v("#")]),e._v(" 设置重试上限和重试次数")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("spring:\n  rabbitmq:\n    listener:\n      simple:\n        acknowledge-mode: auto # 自动ack\n        retry:\n          enabled: true # 开启消费者失败重试\n          initial-interval: 1000ms # 初识的失败等待时长为1秒\n          multiplier: 1 # 失败的等待时长倍数，下次等待时长 = multiplier * last-interval\n          max-attempts: 3 # 最大重试次数\n          stateless: false # true无状态；false有状态。如果业务中包含事务，这里改为false\n")])])]),r("p",[e._v("本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。")]),e._v(" "),r("p",[e._v("因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由"),r("code",[e._v("MessageRecovery")]),e._v("接口来定义的，它有3个不同实现：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("RejectAndDontRequeueRecoverer")]),e._v("：重试耗尽后，直接"),r("code",[e._v("reject")]),e._v("，丢弃消息。默认就是这种方式")]),e._v(" "),r("li",[r("code",[e._v("ImmediateRequeueMessageRecoverer")]),e._v("：重试耗尽后，返回"),r("code",[e._v("nack")]),e._v("，消息重新入队")]),e._v(" "),r("li",[r("strong",[r("code",[e._v("RepublishMessageRecoverer")]),e._v("：重试耗尽后，将失败消息投递到指定的交换机")])])]),e._v(" "),r("h3",{attrs:{id:"设置消息转换器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设置消息转换器"}},[e._v("#")]),e._v(" 设置消息转换器")]),e._v(" "),r("p",[e._v("stateless: false # true无状态；false有状态。如果业务中包含事务，这里改为false")]),e._v(" "),r("p",[e._v("因为设置为false报错，需要依赖消息id")]),e._v(" "),r("p",[e._v("设置消息转换器，自动创建消息id")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("@Bean\npublic MessageConverter messageConverter(){\n    // 1.定义消息转换器\n    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();\n    // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息\n    jackson2JsonMessageConverter.setCreateMessageIds(true);\n    return jackson2JsonMessageConverter;\n}\n")])])]),r("h2",{attrs:{id:"设置消息消费失败处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设置消息消费失败处理"}},[e._v("#")]),e._v(" 设置消息消费失败处理")]),e._v(" "),r("p",[e._v("我们使用"),r("code",[e._v("RepublishMessageRecoverer")]),e._v("策略")]),e._v(" "),r("p",[e._v("创建一个配置类ErrorMessageConfig")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('package com.hmdp.config;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.amqp.rabbit.retry.MessageRecoverer;\nimport org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConditionalOnProperty(name = "spring.rabbitmq.listener.simple.retry.enabled", havingValue = "true")\npublic class ErrorMessageConfig {\n    @Bean\n    public DirectExchange errorMessageExchange() {\n        return new DirectExchange("error.direct");\n    }\n\n    @Bean\n    public Queue errorQueue() {\n        return new Queue("error.queue", true);\n    }\n\n    @Bean\n    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange) {\n        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");\n    }\n\n    @Bean\n    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate) {\n        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");\n    }\n}\n')])])]),r("p",[e._v("再次发送消息可以看到消息消费失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。")]),e._v(" "),r("p",[e._v("不过！！")]),e._v(" "),r("p",[e._v("acknowledge-mode: auto # 自动ack")]),e._v(" "),r("p",[e._v("auto模式如果抛出的是消息转换异常，消息依然会被删除")])])}),[],!1,null,null,null);r.default=t.exports}}]);