(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{411:function(a,t,v){"use strict";v.r(t);var J=v(0),r=Object(J.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"jdk、jre、jvm之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk、jre、jvm之间的区别"}},[a._v("#")]),a._v(" JDK、JRE、JVM之间的区别")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JDK(Java SE Development Kit)是 java 开发工具包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java运行时环境JRE、Java编译器，以及常用的Java类库等")])]),a._v(" "),t("li",[t("p",[a._v("JRE(Java Runtime Environment) ，Java运行环境，用于运行Java的字节码文件，JRE中包括了 JVM以及JVM工作所需要的类库，只需要安装JRE来运行Java程序，而程序开发者必须安装JDK来编译、调试程序。")])]),a._v(" "),t("li",[t("p",[a._v("JVM(Java Virtual Mechinal)，Java虚拟机，是一个运行在计算机上的程序，负责运行字节码文件，它是整个java实现跨平台的最核心的部分。")])]),a._v(" "),t("li",[t("p",[a._v("如果我们要开发Java程序，那就需要JDK来编译Java源文件。 如果我们只想运行已经编译好的Java字节码文件，也就是*.class文件，那么就只需要JRE。 JDK中包含了JRE，JRE中包含了JVM。 另外，JVM在执行Java字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令是有可能 不一样的，所以就导致不同操作系统上的JVM是不一样的，所以我们在安装JDK时需要选择操作系统。 另外，JVM是用来执行Java字节码的，所以编译之后是Java字节码，那就都能在JVM上运行，比如Apache Groovy, Scala and Kotlin 等等。")])])]),a._v(" "),t("h1",{attrs:{id:"为何jdk9要将string底层实现由char-改成byte"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为何jdk9要将string底层实现由char-改成byte"}},[a._v("#")]),a._v(" 为何JDK9要将String底层实现由char[]改成byte[]?")]),a._v(" "),t("p",[a._v("JDK 9并没有将String的底层实现由char [] 改成byte[]，而是在 JDK 9中，引入了Compact Strings的优化，优化的目的是减少String对象的内存消耗。")]),a._v(" "),t("p",[a._v("jdk9中字符串由char[]数组来存储该字符串的所有字符，且内部采用utf-16编码，每个字符占用两个字符，但是如果字符串只包含英文字符或者ASCII字符，这些只需要一个字符就可以存储，这意味着字符串实际存储的空间比需要的空间多一倍\t。引入了Compact String优化，String的底层实现由char[]中改为byte[],只在存储非ASCII字符时使用char[]，对于纯ASCII字符就会存储再byte[]中，从而节省一半的内存空间。这个优化是在编译器和运行时实现，对开发者透明，只需通过虚拟机参数"),t("code",[a._v("-XX:+UseCompressedstrings")]),a._v("控制是否优化。")])])}),[],!1,null,null,null);t.default=r.exports}}]);