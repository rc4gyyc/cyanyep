(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{424:function(v,_,a){"use strict";a.r(_);var t=a(1),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"简述java垃圾回收机制-gc是什么-为什么要gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述java垃圾回收机制-gc是什么-为什么要gc"}},[v._v("#")]),v._v(" 简述Java垃圾回收机制？（GC是什么？为什么要GC）")]),v._v(" "),_("p",[v._v("为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。")]),v._v(" "),_("h2",{attrs:{id:"如何判断堆上的对象有没有被引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何判断堆上的对象有没有被引用"}},[v._v("#")]),v._v(" 如何判断堆上的对象有没有被引用")]),v._v(" "),_("p",[v._v("引用计数法")]),v._v(" "),_("ul",[_("li",[v._v("为每一个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1，存在循环依赖问题，所以java没有使用这种方法")]),v._v(" "),_("li",[v._v("优点：\n"),_("ul",[_("li",[v._v("实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。")]),v._v(" "),_("li",[v._v("在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。")]),v._v(" "),_("li",[v._v("区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。")])])]),v._v(" "),_("li",[v._v("缺点：\n"),_("ul",[_("li",[v._v("每次对象被引用时，都需要去更新计数器，有一点时间开销。")]),v._v(" "),_("li",[_("strong",[v._v("浪费CPU资源")]),v._v("，即使内存够用，仍然在运行时进行计数器的统计。")]),v._v(" "),_("li",[_("strong",[v._v("无法解决循环引用问题，会引发内存泄露")]),v._v("。（最大的缺点）")])])])]),v._v(" "),_("p",[v._v("可达性分析算法")]),v._v(" "),_("ul",[_("li",[v._v("java使用的可达性分析算法来判断对象是否可以被回收，可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象")]),v._v(" "),_("li",[v._v("可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可回收，最常见的GC Root对象会引用栈上的局部变量和静态变量导致对象不可回收。")]),v._v(" "),_("li",[v._v("哪些对象被称之为GC Root对象呢？\n"),_("strong",[v._v("线程Thread对象，引用线程栈帧中的方法参数、局部变量等。")]),v._v("(虚拟机栈（栈帧中的本地变量表）中引用的对象)\n"),_("strong",[v._v("系统类加载器加载的java.lang.Class对象，引用类中的静态变量。")]),v._v("(方法区中类静态属性引用的对象、常量引用的对象)\n监视器对象，用来保存同步锁synchronized关键字持有的对象。\n本地方法调用时使用的全局对象。")])]),v._v(" "),_("h2",{attrs:{id:"jvm的内存模型及其分区-详细每个分区放什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm的内存模型及其分区-详细每个分区放什么"}},[v._v("#")]),v._v(" JVM的内存模型及其分区（详细每个分区放什么）")]),v._v(" "),_("h2",{attrs:{id:"gc算法有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gc算法有哪些"}},[v._v("#")]),v._v(" GC算法有哪些")]),v._v(" "),_("h3",{attrs:{id:"引用计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用计算"}},[v._v("#")]),v._v(" 引用计算")]),v._v(" "),_("h3",{attrs:{id:"标记清除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[v._v("#")]),v._v(" 标记清除")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("将垃圾回收分为2个阶段，分别是"),_("strong",[v._v("标记和清除")]),v._v("。")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("根据可达性分析算法得出的垃圾进行标记")])]),v._v(" "),_("li",[_("p",[v._v("对这些标记为可回收的内容进行垃圾回收")])])])]),v._v(" "),_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("效率较低，"),_("strong",[v._v("标记和清除两个动作都需要遍历所有的对象")]),v._v("，并且在GC时，"),_("strong",[v._v("需要停止应用程序")])])]),v._v(" "),_("li",[_("p",[v._v("（"),_("strong",[v._v("重要")]),v._v("）通过标记清除算法清理出来的内存，碎片化较为严重，")])])])])]),v._v(" "),_("h3",{attrs:{id:"标记压缩-整理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记压缩-整理"}},[v._v("#")]),v._v(" 标记压缩/整理")]),v._v(" "),_("ul",[_("li",[v._v("标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。")]),v._v(" "),_("li",[v._v("优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。")]),v._v(" "),_("li",[v._v("与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理")])]),v._v(" "),_("h3",{attrs:{id:"复制算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[v._v("#")]),v._v(" 复制算法")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("将原有的内存空间一分为二，每次只用其中的一块")]),v._v("，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。")]),v._v(" "),_("li",[v._v("如果内存中的垃圾对象较多，需要复制的对象就较少（用于年轻代）")]),v._v(" "),_("li",[v._v("优点：\n"),_("ul",[_("li",[v._v("在垃圾对象多的情况下，效率较高")]),v._v(" "),_("li",[v._v("清理后，内存无碎片")])])]),v._v(" "),_("li",[v._v("缺点：\n"),_("ul",[_("li",[v._v("分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低")])])])]),v._v(" "),_("h2",{attrs:{id:"分代回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分代回收"}},[v._v("#")]),v._v(" 分代回收")]),v._v(" "),_("h3",{attrs:{id:"堆的区域划分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆的区域划分"}},[v._v("#")]),v._v(" 堆的区域划分")]),v._v(" "),_("ol",[_("li",[v._v("堆被分为了两份：新生代和老年代**【1：2】**")]),v._v(" "),_("li",[v._v("对于新生代，内部又被分为了三个区域。Eden区，幸存者区survivor(分成from和to)"),_("strong",[v._v("【8:1:1】")])])]),v._v(" "),_("h3",{attrs:{id:"对像回收分代回收策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对像回收分代回收策略"}},[v._v("#")]),v._v(" 对像回收分代回收策略")]),v._v(" "),_("ol",[_("li",[v._v("新创建的对象，都会先分配到eden区")]),v._v(" "),_("li",[v._v("当伊甸园内存不足，标记伊甸园与from(现阶段没有)的存活对象")]),v._v(" "),_("li",[v._v("将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和f「o内存都得到释放")]),v._v(" "),_("li",[v._v("经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区")]),v._v(" "),_("li",[v._v("当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会提前晋升）")])]),v._v(" "),_("h3",{attrs:{id:"minorgc、mixed-gc、fullgc的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#minorgc、mixed-gc、fullgc的区别是什么"}},[v._v("#")]),v._v(" MinorGC、Mixed GC、FullGC的区别是什么")]),v._v(" "),_("p",[v._v("MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短(STW)\nMixed GC新生代+老年代部分区域的垃圾回收，G1收集器特有\nFullGC:新生代+老年代完整垃圾回收，暂停时间长(STW),应尽力避免")]),v._v(" "),_("h2",{attrs:{id:"jvm-有哪些垃圾回收器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm-有哪些垃圾回收器"}},[v._v("#")]),v._v(" JVM 有哪些垃圾回收器")]),v._v(" "),_("ul",[_("li",[v._v("串行垃圾收集器")]),v._v(" "),_("li",[v._v("并行垃圾收集器")]),v._v(" "),_("li",[v._v("CMS（并发）垃圾收集器")]),v._v(" "),_("li",[v._v("G1垃圾收集器")])]),v._v(" "),_("h3",{attrs:{id:"串行垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串行垃圾收集器"}},[v._v("#")]),v._v(" 串行垃圾收集器")]),v._v(" "),_("p",[v._v("Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑")]),v._v(" "),_("ul",[_("li",[v._v("Serial 作用于新生代，采用复制算法")]),v._v(" "),_("li",[v._v("Serial Old 作用于老年代，采用标记-整理算法")])]),v._v(" "),_("p",[v._v("垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5C86157%5CDesktop%5Cblog-img%5Cimg%5C1746081474914-1.png",alt:"img"}})]),v._v(" "),_("h3",{attrs:{id:"并行垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并行垃圾收集器"}},[v._v("#")]),v._v(" 并行垃圾收集器")]),v._v(" "),_("p",[v._v("Parallel New和Parallel Old是一个并行垃圾回收器，"),_("strong",[v._v("JDK8默认使用此垃圾回收器")])]),v._v(" "),_("ul",[_("li",[v._v("Parallel New作用于新生代，采用复制算法")]),v._v(" "),_("li",[v._v("Parallel Old作用于老年代，采用标记-整理算法")])]),v._v(" "),_("p",[v._v("垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5C86157%5CDesktop%5Cblog-img%5Cimg%5C1746081484842-4.png",alt:"img"}})]),v._v(" "),_("h3",{attrs:{id:"cms-并发-垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms-并发-垃圾收集器"}},[v._v("#")]),v._v(" CMS（并发）垃圾收集器")]),v._v(" "),_("p",[v._v("CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5C86157%5CDesktop%5Cblog-img%5Cimg%5C1746081985629-7.png",alt:"img"}})]),v._v(" "),_("h3",{attrs:{id:"详细聊一下g1垃圾回收器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#详细聊一下g1垃圾回收器"}},[v._v("#")]),v._v(" 详细聊一下G1垃圾回收器")]),v._v(" "),_("ul",[_("li",[v._v("应用于新生代和老年代，"),_("strong",[v._v("在JDK9之后默认使用G1")])]),v._v(" "),_("li",[v._v("划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备")]),v._v(" "),_("li",[v._v("采用复制算法")]),v._v(" "),_("li",[v._v("响应时间与吞吐量兼顾")]),v._v(" "),_("li",[v._v("分成三个阶段："),_("strong",[v._v("新生代回收、并发标记、混合收集")])]),v._v(" "),_("li",[v._v("如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC")])]),v._v(" "),_("h4",{attrs:{id:"young-collection-年轻代垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#young-collection-年轻代垃圾回收"}},[v._v("#")]),v._v(" Young Collection(年轻代垃圾回收)")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("初始时，所有区域都处于空闲状态")])]),v._v(" "),_("li",[_("p",[v._v("创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象")])]),v._v(" "),_("li",[_("p",[v._v("当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程")])]),v._v(" "),_("li",[_("p",[v._v("随着时间流逝，伊甸园的内存又有不足")])]),v._v(" "),_("li",[_("p",[v._v("将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代")])])]),v._v(" "),_("h4",{attrs:{id:"young-collection-concurrent-mark-年轻代垃圾回收-并发标记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#young-collection-concurrent-mark-年轻代垃圾回收-并发标记"}},[v._v("#")]),v._v(" Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程")])]),v._v(" "),_("li",[_("p",[v._v("并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。")])]),v._v(" "),_("li",[_("p",[v._v("这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。")])])]),v._v(" "),_("h4",{attrs:{id:"mixed-collection-混合垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mixed-collection-混合垃圾回收"}},[v._v("#")]),v._v(" Mixed Collection (混合垃圾回收)")]),v._v(" "),_("p",[v._v("混合收集阶段中，参与复制的有eden、survivor、old")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5C86157%5CDesktop%5Cblog-img%5Cimg%5Cimage-20250501145624250.png",alt:"image-20250501145624250"}})]),v._v(" "),_("p",[v._v("复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集")]),v._v(" "),_("p",[v._v("其中H叫做巨型对象，如果对象非常大，会开辟一块连续的空间存储巨型对象")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5C86157%5CDesktop%5Cblog-img%5Cimg%5C1746083115572-10.png",alt:"img"}})]),v._v(" "),_("h2",{attrs:{id:"轻gc和重gc在什么时候发生"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#轻gc和重gc在什么时候发生"}},[v._v("#")]),v._v(" 轻GC和重GC在什么时候发生")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Minor GC")]),v._v("：Eden区满时触发，高频但快速。")]),v._v(" "),_("li",[_("strong",[v._v("Major GC/Full GC")]),v._v("：老年代或整个堆空间不足时触发，低频但停顿长，需重点优化。")])]),v._v(" "),_("h2",{attrs:{id:"强引用、软引用、弱引用、虚引用的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强引用、软引用、弱引用、虚引用的区别"}},[v._v("#")]),v._v(" 强引用、软引用、弱引用、虚引用的区别")]),v._v(" "),_("h3",{attrs:{id:"强引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强引用"}},[v._v("#")]),v._v(" 强引用")]),v._v(" "),_("p",[v._v("只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收")]),v._v(" "),_("h3",{attrs:{id:"软引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软引用"}},[v._v("#")]),v._v(" 软引用")]),v._v(" "),_("p",[v._v("需要配合SoftReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象")]),v._v(" "),_("h3",{attrs:{id:"弱引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#弱引用"}},[v._v("#")]),v._v(" 弱引用")]),v._v(" "),_("p",[v._v("需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收")]),v._v(" "),_("h3",{attrs:{id:"虚引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚引用"}},[v._v("#")]),v._v(" 虚引用")]),v._v(" "),_("p",[v._v("必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存")])])}),[],!1,null,null,null);_.default=r.exports}}]);