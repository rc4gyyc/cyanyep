(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{423:function(v,_,e){"use strict";e.r(_);var i=e(0),s=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"扫码登录的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扫码登录的实现原理"}},[v._v("#")]),v._v(" 扫码登录的实现原理")]),v._v(" "),_("p",[v._v("扫码登录就是将手机端已经登录的状态同步到PC端或Web端")]),v._v(" "),_("p",[v._v("其主要分为三大步骤：生成二维码、扫码、确认登录")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("生成二维码")]),v._v("：")]),v._v(" "),_("p",[v._v("用户打开PC端登录页面，PC端向后端发送请求，后端就会生成一个唯一的二维码ID，")]),v._v(" "),_("p",[v._v("后端将二维码ID会与二维码的状态（“待扫描”）一起保存在redis中，并生成二维码的图片，二维码图片和二维码ID一对一绑定")]),v._v(" "),_("p",[v._v("PC端显示二维码，等待用户的扫描，同时会与后端建立轮询的请求，定期根据二维码ID向后端查询二维码状态，如果二维码状态改变，PC端会同步更新页面。（当然也可以通过长连接的方式，当二维码状态改变时后端会主动通知PC端，比如淘宝就是用的轮询方式，抖音用的长连接方式。）")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("用户扫码")]),v._v("：")]),v._v(" "),_("p",[v._v("用户扫码后，手机端解析二维码中的二维码ID，携带手机端的用户token、二维码ID向后端发送请求，")]),v._v(" "),_("p",[v._v("后端校验token后会变更二维码状态为已扫描，同时后端会生成一个临时token和二维码ID进行关联并存入redis中，防止二维码重复扫描，并将临时token返回给手机端，")]),v._v(" "),_("p",[v._v("此时PC端轮询到二维码状态变更后，PC端会显示待确认。手机端等待用户确认登录。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("确认登录")]),v._v("：")]),v._v(" "),_("p",[v._v("用户点击确认登录，手机端就会携带临时token向后端发送请求，")]),v._v(" "),_("p",[v._v("后端根据临时token获取二维码ID，并将二维码状态更新为“已登录”，")]),v._v(" "),_("p",[v._v("后端生成一个PC端Token，并与用户信息关联存储在Redis中。此时可以将临时token删除，")]),v._v(" "),_("p",[v._v("PC端通过轮询获取到二维码状态更新（“已登录”）和PC端Token，完成登录流程")])])]),v._v(" "),_("h2",{attrs:{id:"如何使用redis记录上亿用户连续登录天数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何使用redis记录上亿用户连续登录天数"}},[v._v("#")]),v._v(" 如何使用redis记录上亿用户连续登录天数？")]),v._v(" "),_("p",[v._v("可以使用redis的bitmap数据结构")]),v._v(" "),_("p",[v._v("可以从两个维度来记录")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("如果要统计所有用户的连续登录天数")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("可以以日期为bitmap的key，用户id映射到bitmap的位上")])]),v._v(" "),_("li",[_("p",[v._v("有用户登录就将对应的bitmap位置为1，统计所有用户的连续登录天数时，就从当前的日期往前统计，遇到1 就将该用户的连续登录天数加1，遇到0就停止统计")])]),v._v(" "),_("li",[_("p",[v._v("用户id需要唯一")])]),v._v(" "),_("li",[_("p",[v._v("适合于用户量大的情况，而且不建议统计超过30天，可以设置key的过期时间为30天")])])])]),v._v(" "),_("li",[_("p",[v._v("如果要统计单个用户的连续登录天数，需要遍历每一天的bitmap，不方便")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("可以用另一种维度的bitmap，以用户id位bitmap的key，将日期映射到bitmap的位上")])]),v._v(" "),_("li",[_("p",[v._v("登录就置为1，统计单个用户的连续登录天数时，只需要遍历该用户的bitmap，从当前日期往前统计，遇到1计数加1，遇到0停止")])]),v._v(" "),_("li",[_("p",[v._v("这两种存储方式都可以用于统计用户登录天数，具体使用哪种需要结合具体实际情况")])])])])]),v._v(" "),_("h2",{attrs:{id:"session、token、redis、nginx"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session、token、redis、nginx"}},[v._v("#")]),v._v(" session、token、redis、nginx")]),v._v(" "),_("h2",{attrs:{id:"session"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[v._v("#")]),v._v(" session")]),v._v(" "),_("p",[v._v("Session 有状态认证机制，服务器存储用户状态信息。")]),v._v(" "),_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[v._v("安全性高：Session 数据存储在服务器端，客户端只保存 Session ID，不易被篡改。")]),v._v(" "),_("li",[v._v("灵活性高：可以存储任意类型的数据（如用户信息、权限等）。")])]),v._v(" "),_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("服务器压力大：Session 数据存储在服务器端，用户量较大时可能占用大量内存。")]),v._v(" "),_("li",[v._v("扩展性差：在分布式系统中，需要额外的机制（如 Session 复制或集中存储）来共享 Session 数据。")]),v._v(" "),_("li",[v._v("sessioID通过cookie传递，需要设置httpOnly 标志保护cookie来受到xss脚本攻击，不会被js访问到")])]),v._v(" "),_("p",[v._v("适用场景")]),v._v(" "),_("ul",[_("li",[v._v("传统的单体应用。")]),v._v(" "),_("li",[v._v("需要存储复杂用户状态的场景。")])]),v._v(" "),_("h4",{attrs:{id:"session是如何工作的-生命周期是怎么样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session是如何工作的-生命周期是怎么样的"}},[v._v("#")]),v._v(" session是如何工作的，生命周期是怎么样的")]),v._v(" "),_("p",[v._v("工作原理：")]),v._v(" "),_("ul",[_("li",[v._v("用户登录后，服务器创建 Session来保存用户的登录状态 并生成一个唯一的 Session ID。")]),v._v(" "),_("li",[v._v("服务器将 Session ID存入响应头的set-cookie属性中 返回给客户端（通常通过 Cookie）。")]),v._v(" "),_("li",[v._v("客户端会根据 set-cookie 属性自动在cookie中存入 Session ID。")]),v._v(" "),_("li",[v._v("服务器根据 Session ID 查找对应的 Session 数据，验证用户身份。")])]),v._v(" "),_("p",[v._v("生命周期：")]),v._v(" "),_("ul",[_("li",[v._v("创建：用户登录时创建。")]),v._v(" "),_("li",[v._v("销毁：用户登出或 Session 过期时销毁。")])]),v._v(" "),_("h3",{attrs:{id:"session-redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session-redis"}},[v._v("#")]),v._v(" session+redis")]),v._v(" "),_("p",[v._v("使用场景")]),v._v(" "),_("ul",[_("li",[v._v("需要存储用户的状态信息（如权限、临时数据）。")]),v._v(" "),_("li",[v._v("需要支持分布式系统，确保 Session 数据在多个服务节点之间共享。")])]),v._v(" "),_("p",[v._v("实现方式")]),v._v(" "),_("ol",[_("li",[v._v("用户登录：\n"),_("ul",[_("li",[v._v("用户登录后，服务器生成一个唯一的 Session ID，并将用户状态信息（如用户 ID、权限等）存储到 Redis 中。")]),v._v(" "),_("li",[v._v("Session ID 返回给客户端（通常通过 Cookie）。")])])]),v._v(" "),_("li",[v._v("请求处理：\n"),_("ul",[_("li",[v._v("客户端每次请求时携带 Session ID。")]),v._v(" "),_("li",[v._v("服务器根据 Session ID 从 Redis 中获取用户状态信息，完成业务逻辑。")])])]),v._v(" "),_("li",[v._v("用户登出：\n"),_("ul",[_("li",[v._v("客户端删除本地 Session ID。")]),v._v(" "),_("li",[v._v("服务器从 Redis 中删除对应的 Session 数据。")])])])]),v._v(" "),_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[v._v("数据共享：Redis 作为集中存储，支持分布式系统。")])]),v._v(" "),_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("性能依赖 Redis：Redis 的性能和可用性直接影响系统表现。")]),v._v(" "),_("li",[v._v("扩展性有限：Session 数据量较大时，Redis 内存占用较高。")])]),v._v(" "),_("h3",{attrs:{id:"为什么没有使用nginx-session的方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么没有使用nginx-session的方案"}},[v._v("#")]),v._v(" 为什么没有使用nginx+session的方案")]),v._v(" "),_("p",[v._v("虽然nginx可以通过配置 "),_("code",[v._v("ip_hash")]),v._v(" 或者 sticky 模块来确保用户的请求被路由到同一个服务器。")]),v._v(" "),_("p",[v._v("但是在高并发场景下（如抢优惠券），如果恰好用户会话都在同一个服务器，大量用户同时发起请求都被路由到同一个服务器，会导致该服务器过载，而其他服务器可能处于空闲状态，无法有效利用集群资源。")]),v._v(" "),_("p",[v._v("此外，如果系统向微服务架构演进，传统的Session机制存在一些不足。Session数据需要存储在共享存储（如Redis或数据库）中，以便不同服务能够访问用户的会话信息。这种方式增加了系统的复杂性和维护成本，尤其是在分布式环境中，还需要考虑数据一致性、容错性等问题。")]),v._v(" "),_("p",[v._v("基于上述情况，我们还是选择了基于Token的认证机制（如 JWT）， 因为它每个请求都携带完整的身份验证信息，不需要依赖于共享Session存储，可以很好地支持微服务架构中的跨服务调用，容易扩展和管理")]),v._v(" "),_("h2",{attrs:{id:"token"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#token"}},[v._v("#")]),v._v(" token")]),v._v(" "),_("p",[_("strong",[v._v("Token")]),v._v(" 是无状态认证机制，用户信息存储在 Token 中（如  JSON Web Token（JWT））")]),v._v(" "),_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[v._v("无状态：服务器不需要存储 Token，适合分布式系统和微服务架构。")]),v._v(" "),_("li",[v._v("灵活性：可以在不同服务之间自由传递，适合微服务架构中的跨服务调用。")]),v._v(" "),_("li",[v._v("跨域支持：Token 可以轻松实现跨域认证。")]),v._v(" "),_("li",[v._v("可扩展性：由于是无状态的，容易扩展和管理")])]),v._v(" "),_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("安全性依赖实现：Token 存储在客户端，可能被窃取或篡改（需使用 HTTPS 和签名机制增强安全性）。")]),v._v(" "),_("li",[v._v("无法中途撤销：Token 一旦签发，在有效期内无法撤销（除非引入黑名单机制）。")]),v._v(" "),_("li",[v._v("数据膨胀：Token 包含用户信息，可能导致数据量较大。")])]),v._v(" "),_("p",[v._v("适用场景")]),v._v(" "),_("ul",[_("li",[v._v("分布式系统和微服务架构。")]),v._v(" "),_("li",[v._v("跨域认证和单点登录（SSO）。")])]),v._v(" "),_("h4",{attrs:{id:"token是如何保证无状态认证的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#token是如何保证无状态认证的"}},[v._v("#")]),v._v(" token是如何保证无状态认证的")]),v._v(" "),_("p",[v._v("工作原理")]),v._v(" "),_("ul",[_("li",[v._v("用户登录后，服务器生成 Token 并返回给客户端。")]),v._v(" "),_("li",[v._v("客户端保存 Token（通常存储在 LocalStorage 或 Cookie 中）。")]),v._v(" "),_("li",[v._v("客户端每次请求时携带 Token。")]),v._v(" "),_("li",[v._v("服务器验证 Token 的签名和有效期，并从中提取用户信息。")])]),v._v(" "),_("p",[v._v("这样服务器就不用存储token，只需验证用户请求中的token是否有效，签名是否验证通过，并从中获取用户信息就能验证用户的身份。")]),v._v(" "),_("h2",{attrs:{id:"jwt"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[v._v("#")]),v._v(" JWT")]),v._v(" "),_("p",[v._v("JWT是一种开放标准，通常用于身份验证和信息交换，又三个部分组成：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Header")]),v._v("：包含算法和类型（如 "),_("code",[v._v('{"alg": "HS256", "typ": "JWT"}')]),v._v("）。")]),v._v(" "),_("li",[_("strong",[v._v("Payload")]),v._v("：包含用户信息和其他数据（如 "),_("code",[v._v('{"sub": "123", "name": "John"}')]),v._v("）。")]),v._v(" "),_("li",[_("strong",[v._v("Signature")]),v._v("：对 Header 和 Payload 的签名，用于验证 Token 的完整性。")])]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("jwt是无状态的，没有办法取消令牌强制用户下线，只能把用户状态保存下来，但也改变了它的作用")])]),v._v(" "),_("li",[_("p",[v._v("jwt是不加密的，不能传输敏感信息")])]),v._v(" "),_("li",[_("p",[v._v("占用大小要比session大很多")])])]),v._v(" "),_("h3",{attrs:{id:"如何实现双-token-机制-它的优点是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何实现双-token-机制-它的优点是什么"}},[v._v("#")]),v._v(" 如何实现双 Token 机制？它的优点是什么？")]),v._v(" "),_("ul",[_("li",[v._v("实现：\n"),_("ol",[_("li",[v._v("用户登录后，生成 Access Token 和 Refresh Token。")]),v._v(" "),_("li",[v._v("Access Token 用于访问资源，Refresh Token 用于刷新 Access Token。")])])]),v._v(" "),_("li",[v._v("优点：\n"),_("ul",[_("li",[v._v("提高安全性：Access Token 有效期短，减少泄露风险。")]),v._v(" "),_("li",[v._v("提升用户体验：用户无需频繁登录。")])])])]),v._v(" "),_("h3",{attrs:{id:"如何实现单点登录-sso-session-和-token-在-sso-中分别如何应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何实现单点登录-sso-session-和-token-在-sso-中分别如何应用"}},[v._v("#")]),v._v(" 如何实现单点登录（SSO）？Session 和 Token 在 SSO 中分别如何应用？")]),v._v(" "),_("p",[v._v("SSO 实现：")]),v._v(" "),_("ul",[_("li",[v._v("用户登录认证中心，生成 Token。")]),v._v(" "),_("li",[v._v("认证中心将 Token 返回给客户端。")]),v._v(" "),_("li",[v._v("客户端携带 Token 访问其他系统。")]),v._v(" "),_("li",[v._v("其他系统验证 Token 的合法性。")])]),v._v(" "),_("p",[v._v("Session：认证中心存储用户状态，其他系统通过共享 Session 实现 SSO。")]),v._v(" "),_("p",[v._v("Token：认证中心生成 Token，其他系统通过验证 Token 实现 SSO。")]),v._v(" "),_("h3",{attrs:{id:"jwt的滑动过期机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jwt的滑动过期机制"}},[v._v("#")]),v._v(" JWT的滑动过期机制")]),v._v(" "),_("p",[v._v("每当用户发起请求时，如果当前的Token即将过期，则生成一个新的Token，并延长其有效期。这样，只要用户保持一定的活动频率，其会话就不会过期；但如果用户在一定时间内没有进行任何操作，则会话将过期，需要重新登录。")]),v._v(" "),_("p",[v._v("性能考虑：频繁地生成新Token可能会对性能造成影响。")]),v._v(" "),_("p",[v._v("用户体验：确保良好的用户体验，让用户在无需手动干预的情况下保持登录状态，")]),v._v(" "),_("p",[v._v("潜在的安全风险：如果Token泄露且没有其他安全措施（如黑名单机制），攻击者可以无限期地保持登录状态。")]),v._v(" "),_("h3",{attrs:{id:"在分布式系统中如何处理jwt的滑动过期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在分布式系统中如何处理jwt的滑动过期"}},[v._v("#")]),v._v(" 在分布式系统中如何处理JWT的滑动过期")]),v._v(" "),_("p",[v._v("token+redis")]),v._v(" "),_("p",[v._v("使用场景")]),v._v(" "),_("ul",[_("li",[v._v("需要无状态认证，支持跨域和分布式系统。")]),v._v(" "),_("li",[v._v("需要存储 Token 的附加信息（如黑名单、用户权限）。")])]),v._v(" "),_("p",[v._v("实现方式")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("用户登录")]),v._v("：\n"),_("ul",[_("li",[v._v("用户登录后，服务器生成一个 Token（如 JWT），并将其返回给客户端。")]),v._v(" "),_("li",[v._v("同时，将 Token 的附加信息（如用户权限、黑名单状态）存储到 Redis 中。")])])]),v._v(" "),_("li",[_("strong",[v._v("请求处理")]),v._v("：\n"),_("ul",[_("li",[v._v("客户端每次请求时携带 Token。")]),v._v(" "),_("li",[v._v("服务器验证 Token 的合法性，并从 Redis 中获取附加信息（如权限）。")])])]),v._v(" "),_("li",[_("strong",[v._v("用户登出")]),v._v("：\n"),_("ul",[_("li",[v._v("客户端删除本地 Token。")]),v._v(" "),_("li",[v._v("服务器将 Token 加入 Redis 黑名单（或直接删除附加信息）。")])])])]),v._v(" "),_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("无状态")]),v._v("：Token 自包含用户信息，适合分布式系统。")]),v._v(" "),_("li",[_("strong",[v._v("扩展性好")]),v._v("：Redis 存储附加信息，支持复杂业务逻辑。")])]),v._v(" "),_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("实现复杂")]),v._v("：需要结合 Token 和 Redis 的逻辑。")]),v._v(" "),_("li",[_("strong",[v._v("性能依赖 Redis")]),v._v("：Redis 的性能和可用性直接影响系统表现。")])]),v._v(" "),_("h3",{attrs:{id:"redis-token-和-jwt-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-token-和-jwt-的区别"}},[v._v("#")]),v._v(" Redis + Token 和 JWT 的区别")]),v._v(" "),_("p",[v._v("Redis + Token 方案")]),v._v(" "),_("ul",[_("li",[v._v("生成Token：当用户登录成功后，服务器生成一个唯一的Token（通常是一个随机字符串），并将其存储在Redis中，同时将Token返回给客户端。")]),v._v(" "),_("li",[v._v("存储Token：Redis作为内存数据库，能够高效地存储和检索Token。每个Token可以关联用户的会话信息或其他必要数据。")]),v._v(" "),_("li",[v._v("验证Token：每次请求到来时，服务器从请求头中提取Token，并在Redis中查找该Token。如果找到，则认为请求合法，并继续处理；否则拒绝请求。")]),v._v(" "),_("li",[_("strong",[v._v("管理Token生命周期")]),v._v("：通过设置Redis中的Key的过期时间来控制Token的有效期。也可以手动删除或更新Token。")])]),v._v(" "),_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[v._v("状态化管理：由于Token存储在服务器端的Redis中，服务端可以完全控制Token的状态，便于管理和撤销。")]),v._v(" "),_("li",[v._v("高性能：Redis是内存数据库，读写速度非常快，适合高并发场景。")]),v._v(" "),_("li",[v._v("灵活控制：可以根据需要动态调整Token的有效期或立即失效（如用户登出时）。")])]),v._v(" "),_("p",[v._v("缺点：额外依赖：需要引入Redis等外部存储系统，增加了系统的复杂性和运维成本。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("JWT 方案")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("工作机制")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("生成JWT：当用户登录成功后，服务器使用密钥对包含用户信息的Payload进行签名，生成JWT，并将其返回给客户端。")])]),v._v(" "),_("li",[_("p",[v._v("传递JWT：客户端收到JWT后，通常将其存储在LocalStorage或Cookie中，并在后续请求中通过HTTP Header（如"),_("code",[v._v("Authorization: Bearer <token>")]),v._v("）传递给服务器。")])]),v._v(" "),_("li",[_("p",[v._v("验证JWT：每次请求到来时，服务器从请求头中提取JWT，并使用相同的密钥对其进行验证。如果验证通过，则解码Payload获取用户信息；否则拒绝请求。")])]),v._v(" "),_("li",[_("p",[v._v("管理JWT生命周期：JWT自带有效期（"),_("code",[v._v("exp")]),v._v("字段），一旦生成无法直接修改其内容或撤销。可以通过结合Refresh Token机制延长用户会话。")])])])]),v._v(" "),_("li",[_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("无状态：JWT包含了所有必要的信息，服务器无需存储任何会话状态，易于扩展和维护。")])]),v._v(" "),_("li",[_("p",[v._v("减少网络开销：不需要额外查询数据库或缓存，减少了网络延迟和负载。")])]),v._v(" "),_("li",[_("p",[v._v("跨域友好：由于JWT是自包含的，非常适合前后端分离和跨域应用场景。")])])])]),v._v(" "),_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("不可撤销：一旦签发，除非过期，否则无法直接撤销特定用户的Token。需要额外机制（如黑名单）来处理这种情况。")])]),v._v(" "),_("li",[_("p",[v._v("大小限制：由于 JWT需要在网络上传输，其大小不宜过大，特别是当需要携带大量用户信息时。")])]),v._v(" "),_("li",[_("p",[v._v("安全性风险：如果密钥泄露，攻击者可以伪造任意有效的 JWT。")])])])])]),v._v(" "),_("h3",{attrs:{id:"session-和-token-可以结合使用吗-如果可以-如何实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session-和-token-可以结合使用吗-如果可以-如何实现"}},[v._v("#")]),v._v(" Session 和 Token 可以结合使用吗？如果可以，如何实现？")]),v._v(" "),_("ul",[_("li",[v._v("可以结合使用：\n"),_("ul",[_("li",[v._v("使用 Token 进行无状态认证。")]),v._v(" "),_("li",[v._v("将敏感数据（如权限）存储到服务器端的 Session 中。")]),v._v(" "),_("li",[v._v("通过 Redis 共享 Session 数据。")])])])]),v._v(" "),_("h2",{attrs:{id:"cookie、session、jwt"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie、session、jwt"}},[v._v("#")]),v._v(" Cookie、Session、JWT")]),v._v(" "),_("p",[v._v("Cookie")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("工作流程")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("用户登录后服务器后验证用户名和密码，")])]),v._v(" "),_("li",[_("p",[v._v("验证通过将用户名放入响应头的set-cookie属性中")])]),v._v(" "),_("li",[_("p",[v._v("客户端发出请求就会根据set-cookie属性自动将用户名放入cookie中")])]),v._v(" "),_("li",[_("p",[v._v("服务器根据cookie中的用户名进行身份验证")])])])]),v._v(" "),_("li",[_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("cookie中的用户名容易被篡改")]),v._v(" "),_("li",[v._v("cookie的容量时优先的")]),v._v(" "),_("li",[v._v("cookie可能被用户禁用")])])])]),v._v(" "),_("p",[v._v("Session")]),v._v(" "),_("ul",[_("li",[v._v("工作流程\n"),_("ul",[_("li",[v._v("用户登录后服务器会将用户信息存放在session中并生成一个唯一的sessionID与之对应")]),v._v(" "),_("li",[v._v("将SessionID放入响应头的set-cookie属性中")]),v._v(" "),_("li",[v._v("客户端根据set-cookie属性会自动把sessionID放入cookie中")]),v._v(" "),_("li",[v._v("服务器根据cookie中的sessionID对应到session中获取用户信息进行身份验证")])])]),v._v(" "),_("li",[v._v("缺点：\n"),_("ul",[_("li",[v._v("高并发下，服务器会占用大量资源")]),v._v(" "),_("li",[v._v("扩展性差，分布式环境下需要进行集群间session同步或者进行session共享存储")]),v._v(" "),_("li",[v._v("依然需要使用cookie，在前后端分离架构下会有跨域限制，需要进行响应的CORS配置")])])])]),v._v(" "),_("p",[v._v("JWT")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("工作流程")]),v._v(" "),_("ul",[_("li",[v._v("用户登录后服务器将用户信息保存在JWT中返回被客户端")]),v._v(" "),_("li",[v._v("客户端可以通过cookie或者将JWT放入请求头中发送给服务器")]),v._v(" "),_("li",[v._v("服务器对JWT进行验证，保证JWT有效且没有被篡改，从中获取用户信息")])])]),v._v(" "),_("li",[_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("由于JWT是无状态的，扩展性好，适合微服务和分布式系统")])])]),v._v(" "),_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("相较于简单的SessionID，JWT比较大，")]),v._v(" "),_("li",[v._v("一旦签发，除非过期，否则无法撤销")])])])]),v._v(" "),_("h3",{attrs:{id:"session-和-token-分别有哪些安全性问题-如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session-和-token-分别有哪些安全性问题-如何解决"}},[v._v("#")]),v._v(" Session 和 Token 分别有哪些安全性问题？如何解决？")]),v._v(" "),_("ul",[_("li",[v._v("Session：\n"),_("ul",[_("li",[v._v("问题：Session 劫持(如网络监听、xss脚本攻击)")]),v._v(" "),_("li",[v._v("解决：\n"),_("ul",[_("li",[v._v("使用 HTTPS防止网络监听、使用Secure 标记确保Cookie只能通过HTTPS传输，防止通过HTTP明文传输时被截获。")]),v._v(" "),_("li",[v._v("使用HttpOnly标志可以防止 JavaScript访问Cookie，有效防御XSS攻击")])])])])]),v._v(" "),_("li",[v._v("Token：\n"),_("ul",[_("li",[v._v("问题：Token截取、Token 泄露、重放攻击、CSRF（跨站请求伪造）。")]),v._v(" "),_("li",[v._v("解决：\n"),_("ul",[_("li",[v._v("使用 HTTPS防止中间人攻击和网络监听")]),v._v(" "),_("li",[v._v("设置较短的 Token 有效期、使用 Refresh Token（双Token机制）")]),v._v(" "),_("li",[v._v("使用CSRF Token，设置"),_("code",[v._v("SameSite")]),v._v(" 标志属性为"),_("code",[v._v("Strict")]),v._v("或"),_("code",[v._v("Lax")]),v._v("。")])])])])])]),v._v(" "),_("h3",{attrs:{id:"在选择将jwt存储在localstorage还是cookie时-你认为哪种方式更好-为什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在选择将jwt存储在localstorage还是cookie时-你认为哪种方式更好-为什么"}},[v._v("#")]),v._v(" 在选择将JWT存储在LocalStorage还是Cookie时，你认为哪种方式更好？为什么？")]),v._v(" "),_("p",[v._v("LocalStorage")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("存储容量大：LocalStorage 可以存储较大数据（通常为 5MB），适合存储较长的 JWT。")])]),v._v(" "),_("li",[_("p",[v._v("前端控制：前端可以完全控制 JWT 的存储和读取，灵活性高。")])]),v._v(" "),_("li",[_("p",[v._v("跨域支持：LocalStorage 不受同源策略限制，适合前后端分离的架构。")])])])]),v._v(" "),_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("安全性较低：LocalStorage 容易受到 XSS（跨站脚本攻击）的影响，攻击者可以通过注入恶意脚本窃取 JWT。")])]),v._v(" "),_("li",[_("p",[v._v("手动管理：需要"),_("strong",[v._v("手动将 JWT 添加到请求头中")]),v._v("（如 "),_("code",[v._v("Authorization: Bearer <token>")]),v._v("）。")])])])]),v._v(" "),_("li",[_("p",[v._v("安全性增强：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("使用 HTTPS 加密传输。")])]),v._v(" "),_("li",[_("p",[v._v("对 JWT 进行加密或签名。")])]),v._v(" "),_("li",[_("p",[v._v("设置较短的 Token 有效期。")])])])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("Cookie")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("安全性较高：")]),v._v(" "),_("ul",[_("li",[v._v("可以设置 "),_("code",[v._v("HttpOnly")]),v._v(" 标志，防止 JavaScript 访问 Cookie，减少 XSS 攻击的风险。")]),v._v(" "),_("li",[v._v("可以设置 "),_("code",[v._v("Secure")]),v._v(" 标志，确保 Cookie 仅通过 HTTPS 传输。")]),v._v(" "),_("li",[v._v("可以设置 "),_("code",[v._v("SameSite")]),v._v(" 标志，防止 CSRF（跨站请求伪造）攻击。")])])]),v._v(" "),_("li",[_("p",[v._v("自动管理：浏览器会"),_("strong",[v._v("自动将 Cookie 附加到每个请求中")]),v._v("，无需手动管理。")])])])]),v._v(" "),_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("存储容量小：每个 Cookie 的大小通常限制在 4KB 左右，不适合存储较长的 JWT。")])]),v._v(" "),_("li",[_("p",[v._v("跨域限制：受同源策略限制，跨域请求"),_("strong",[v._v("需要额外配置 CORS")]),v._v("。")])])])]),v._v(" "),_("li",[_("p",[v._v("高安全性场景：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("优先选择 "),_("strong",[v._v("Cookie")]),v._v("，并严格设置安全标志。")])]),v._v(" "),_("li",[_("p",[v._v("结合双 Token 机制（Access Token 和 Refresh Token），进一步提高安全性。")])])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);