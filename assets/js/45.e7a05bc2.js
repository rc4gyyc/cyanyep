(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{418:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"线程和进程的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程的区别"}},[v._v("#")]),v._v(" 线程和进程的区别？")]),v._v(" "),_("ul",[_("li",[v._v("进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务")]),v._v(" "),_("li",[v._v("不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间")]),v._v(" "),_("li",[v._v("线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)")])]),v._v(" "),_("h3",{attrs:{id:"并行和并发有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并行和并发有什么区别"}},[v._v("#")]),v._v(" 并行和并发有什么区别？")]),v._v(" "),_("p",[v._v("现在都是多核CPU，在多核CPU下\n并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU\n并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程")]),v._v(" "),_("h3",{attrs:{id:"创建线程的四种方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#创建线程的四种方式"}},[v._v("#")]),v._v(" 创建线程的四种方式")]),v._v(" "),_("p",[v._v("在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。")]),v._v(" "),_("h3",{attrs:{id:"runnable-和-callable-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#runnable-和-callable-有什么区别"}},[v._v("#")]),v._v(" runnable 和 callable 有什么区别")]),v._v(" "),_("ol",[_("li",[v._v("Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果")]),v._v(" "),_("li",[v._v("Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。")]),v._v(" "),_("li",[v._v("Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛")])]),v._v(" "),_("h3",{attrs:{id:"线程的-run-和-start-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的-run-和-start-有什么区别"}},[v._v("#")]),v._v(" 线程的 run()和 start()有什么区别？")]),v._v(" "),_("p",[v._v("start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。")]),v._v(" "),_("p",[v._v("run(): 封装了要被线程执行的代码，可以被调用多次。")]),v._v(" "),_("h2",{attrs:{id:"线程包括哪些状态-状态之间是如何变化的-java线程的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程包括哪些状态-状态之间是如何变化的-java线程的生命周期"}},[v._v("#")]),v._v(" 线程包括哪些状态，状态之间是如何变化的/Java线程的生命周期")]),v._v(" "),_("p",[v._v("在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有限等待六种。")]),v._v(" "),_("p",[v._v("关于线程的状态切换情况比较多。我分别介绍一下")]),v._v(" "),_("p",[v._v("当一个线程对象被创建，但还未调用 start 方法时处于"),_("strong",[v._v("新建NEW")]),v._v("状态，调用了 start 方法，就会由"),_("strong",[v._v("新建")]),v._v("进入"),_("strong",[v._v("可运行RUNNABLE")]),v._v("状态。如果线程内代码已经执行完毕，由"),_("strong",[v._v("可运行")]),v._v("进入"),_("strong",[v._v("终结TERMINATED")]),v._v("状态。当然这些是一个线程正常执行情况。")]),v._v(" "),_("p",[v._v("如果线程获取锁失败后，由"),_("strong",[v._v("可运行")]),v._v("进入 Monitor 的阻塞队列"),_("strong",[v._v("阻塞BLOCKED")]),v._v("，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的"),_("strong",[v._v("阻塞")]),v._v("线程，唤醒后的线程进入"),_("strong",[v._v("可运行")]),v._v("状态")]),v._v(" "),_("p",[v._v("如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从"),_("strong",[v._v("可运行")]),v._v("状态释放锁"),_("strong",[v._v("等待WAITING")]),v._v("状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为"),_("strong",[v._v("可运行")]),v._v("状态")]),v._v(" "),_("p",[v._v("还有一种情况是调用 sleep(long) 方法也会从"),_("strong",[v._v("可运行")]),v._v("状态进入"),_("strong",[v._v("有时限等待TIMED_WAITING")]),v._v("状态，不需要主动唤醒，超时时间到自然恢复为"),_("strong",[v._v("可运行")]),v._v("状态")]),v._v(" "),_("p",[v._v("线程可以通过三种方法进入"),_("code",[v._v("WAITING")]),v._v("状态：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Object.wait()")]),v._v("：等待其他线程调用"),_("code",[v._v("notify()")]),v._v("或"),_("code",[v._v("notifyAll()")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("Thread.join()")]),v._v("：等待目标线程执行完毕。")]),v._v(" "),_("li",[_("code",[v._v("LockSupport.park()")]),v._v("：暂停当前线程。")])]),v._v(" "),_("p",[v._v("线程进入等待状态，但会在指定的时间后自动唤醒。线程可以通过四种带有超时时间的方法进入"),_("code",[v._v("TIMED_WAITING")]),v._v("状态：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Thread.sleep(long millis)")]),v._v("：睡眠指定时间。")]),v._v(" "),_("li",[_("code",[v._v("Object.wait(long timeout)")]),v._v("：等待指定时间。")]),v._v(" "),_("li",[_("code",[v._v("Thread.join(long millis)")]),v._v("：等待目标线程指定时间。")]),v._v(" "),_("li",[_("code",[v._v("LockSupport.parkNanos(long nanos)")]),v._v("：暂停当前线程指定时间。")])]),v._v(" "),_("h3",{attrs:{id:"新建-t1、t2、t3-三个线程-如何保证它们按顺序执行-⭐⭐⭐"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新建-t1、t2、t3-三个线程-如何保证它们按顺序执行-⭐⭐⭐"}},[v._v("#")]),v._v(" 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？⭐⭐⭐")]),v._v(" "),_("p",[v._v("可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。")]),v._v(" "),_("p",[v._v("比如说：")]),v._v(" "),_("p",[v._v("使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成")]),v._v(" "),_("h3",{attrs:{id:"notify-和-notifyall-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#notify-和-notifyall-有什么区别"}},[v._v("#")]),v._v(" notify()和 notifyAll()有什么区别？")]),v._v(" "),_("p",[v._v("notifyAll：唤醒所有wait的线程")]),v._v(" "),_("p",[v._v("notify：只随机唤醒一个 wait 线程")]),v._v(" "),_("h3",{attrs:{id:"java-中-wait-和-sleep-方法的不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-中-wait-和-sleep-方法的不同"}},[v._v("#")]),v._v(" java 中 wait 和 sleep 方法的不同？")]),v._v(" "),_("p",[v._v("共同点")]),v._v(" "),_("ul",[_("li",[v._v("wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态")])]),v._v(" "),_("p",[v._v("不同点")]),v._v(" "),_("ul",[_("li",[v._v("方法归属不同\n"),_("ul",[_("li",[v._v("sleep(long) 是 Thread 的静态方法")]),v._v(" "),_("li",[v._v("而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有")])])]),v._v(" "),_("li",[v._v("醒来时机不同\n"),_("ul",[_("li",[v._v("执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来")]),v._v(" "),_("li",[v._v("wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去")]),v._v(" "),_("li",[v._v("它们都可以被打断唤醒")])])]),v._v(" "),_("li",[v._v("锁特性不同（重点）\n"),_("ul",[_("li",[v._v("wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制")]),v._v(" "),_("li",[v._v("wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）")]),v._v(" "),_("li",[v._v("而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）")])])])]),v._v(" "),_("h3",{attrs:{id:"如何停止一个正在运行的线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何停止一个正在运行的线程"}},[v._v("#")]),v._v(" 如何停止一个正在运行的线程？")]),v._v(" "),_("p",[v._v("有三种方式可以停止线程")]),v._v(" "),_("ul",[_("li",[v._v("使用退出标志，使线程正常退出，也就是当run方法完成后线程终止")]),v._v(" "),_("li",[v._v("使用stop方法强行终止（不推荐，方法已作废）")]),v._v(" "),_("li",[v._v("使用interrupt方法中断线程（修改中断状态，需要使用interrupt判断中断状态主动结束线程，如果线程是等待状态则会抛出InterruptedException ）")])])])}),[],!1,null,null,null);_.default=l.exports}}]);