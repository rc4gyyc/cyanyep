(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{433:function(v,_,e){"use strict";e.r(_);var r=e(1),a=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"为什么要使用spring框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用spring框架"}},[v._v("#")]),v._v(" 为什么要使用spring框架")]),v._v(" "),_("p",[v._v("Spring 是一个"),_("strong",[v._v("轻量级")]),v._v("的"),_("strong",[v._v("企业级应用框架")]),v._v("，其核心是 "),_("strong",[v._v("IoC（控制反转）")]),v._v(" 和 "),_("strong",[v._v("AOP（面向切面编程）")]),v._v("，旨在"),_("strong",[v._v("简化企业级开发")]),v._v("，让开发者专注于"),_("strong",[v._v("业务逻辑")]),v._v("，而无需手动管理对象依赖或侵入式编码。")]),v._v(" "),_("p",[v._v("从spring本身的特性")]),v._v(" "),_("ol",[_("li",[v._v("spring是一个轻量级的框架，它的基本版本呢只有两兆，")]),v._v(" "),_("li",[v._v("spring通过IOC容器管理 Bean 的生命周期，以及通过DI实现松耦合，降低组件间的直接依赖，")]),v._v(" "),_("li",[v._v("spring提供了AOP的面向切面编程功能，可以把我们的业务逻辑和系统功能之间，进行一个切分，")]),v._v(" "),_("li",[v._v("MVC的框架，spring mvc呢提供的功能更加强大，且更加灵活的一个web框架的一个支持")]),v._v(" "),_("li",[v._v("spring基于 "),_("strong",[v._v("AOP")]),v._v(" 实现"),_("strong",[v._v("统一事务控制")]),v._v("，支持编程式 & 声明式事务，简化数据库操作。")]),v._v(" "),_("li",[v._v("丰富的生态 & 社区支持，Spring Boot（快速开发）、Spring Cloud（微服务）、Spring Data（数据访问）等")])]),v._v(" "),_("h2",{attrs:{id:"_1-spring框架中的单例bean是线程安全的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring框架中的单例bean是线程安全的吗"}},[v._v("#")]),v._v(" 1. Spring框架中的单例bean是线程安全的吗？")]),v._v(" "),_("p",[v._v("不是线程安全的。当多用户同时请求一个服务时，容器会给每个请求分配一个线程，这些线程会并发执行业务逻辑。如果处理逻辑中包含对单例状态的修改，比如修改单例的成员属性，就必须考虑线程同步问题。Spring框架本身并不对单例bean进行线程安全封装，线程安全和并发问题需要开发者自行处理。")]),v._v(" "),_("p",[v._v("通常在项目中使用的Spring bean是不可变状态（如Service类和DAO类），因此在某种程度上可以说Spring的单例bean是线程安全的。如果bean有多种状态（如View Model对象），就需要自行保证线程安全。最简单的解决办法是将单例bean的作用域由“singleton”变更为“prototype”。")]),v._v(" "),_("h2",{attrs:{id:"_2-什么是aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是aop"}},[v._v("#")]),v._v(" 2. 什么是AOP？")]),v._v(" "),_("p",[v._v("AOP，即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。常见的应用场景包括公共日志保存和事务处理。")]),v._v(" "),_("h3",{attrs:{id:"_3-你们项目中有没有使用到aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-你们项目中有没有使用到aop"}},[v._v("#")]),v._v(" 3. 你们项目中有没有使用到AOP？")]),v._v(" "),_("p",[v._v("我们之前在后台管理系统中使用AOP来记录系统操作日志。主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。")]),v._v(" "),_("h3",{attrs:{id:"_4-spring中的事务是如何实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-spring中的事务是如何实现的"}},[v._v("#")]),v._v(" 4. Spring中的事务是如何实现的？")]),v._v(" "),_("p",[v._v("Spring实现事务的本质是利用AOP完成的。它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。")]),v._v(" "),_("h3",{attrs:{id:"_5-spring中事务失效的场景有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-spring中事务失效的场景有哪些"}},[v._v("#")]),v._v(" 5. Spring中事务失效的场景有哪些？")]),v._v(" "),_("p",[v._v("在项目中，我遇到过几种导致事务失效的场景：")]),v._v(" "),_("ol",[_("li",[v._v("如果方法内部捕获并处理了异常，没有将异常抛出，会导致事务失效。因此，处理异常后应该确保异常能够被抛出。")]),v._v(" "),_("li",[v._v("如果方法抛出非RuntimeException/Error，即检查型异常（checked exception），并且没有在"),_("code",[v._v("@Transactional")]),v._v("注解上配置"),_("code",[v._v("rollbackFor")]),v._v("属性为"),_("code",[v._v("Exception")]),v._v("，那么异常发生时事务可能不会回滚。")]),v._v(" "),_("li",[v._v("如果事务注解的方法不是公开（public）修饰的，也可能导致事务失效。")]),v._v(" "),_("li",[v._v("自调用：如果在类内部方法直接调用带@Transaction的方法，会绕过AOP代理，导致事务失效")])]),v._v(" "),_("h2",{attrs:{id:"_6-spring的bean的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-spring的bean的生命周期"}},[v._v("#")]),v._v(" 6. Spring的bean的生命周期？")]),v._v(" "),_("p",[v._v("Spring的Bean生命周期主要分为五大步")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("实例化")]),v._v(" "),_("ol",[_("li",[v._v("通过"),_("code",[v._v("BeanDefinition")]),v._v("获取bean的定义信息(beanClassName、initMethodName、propertyValues、scope、lazyInit)。")]),v._v(" "),_("li",[v._v("通过反射调用构造函数或工厂方法创建Bean对象。")])])]),v._v(" "),_("li",[_("p",[v._v("属性赋值")])]),v._v(" "),_("li",[_("p",[v._v("进行bean的依赖注入：通过Setter方法、字段注入（如"),_("code",[v._v("@Autowired")]),v._v("）或构造器注入完成属性赋值")])]),v._v(" "),_("li",[_("p",[v._v("处理循环依赖")])]),v._v(" "),_("li",[_("p",[v._v("Aware接口回调")]),v._v(" "),_("ol",[_("li",[v._v("若Bean实现了"),_("code",[v._v("Aware")]),v._v("接口(BeanNameAware、BeanFactoryAware、ApplicationContextA ware)，会调用相关的Aware注入BeanName、容器等底层资源")])])]),v._v(" "),_("li",[_("p",[v._v("初始化")]),v._v(" "),_("ol",[_("li",[v._v("BeanPostProcessor前置处理")]),v._v(" "),_("li",[v._v("调用初始化生命周期回调（@PostConstruct、InitializingBean#afterPropertiesSet()、init-method）")]),v._v(" "),_("li",[v._v("BeanPostProcessor后置处理 "),_("strong",[v._v("可能在这里产生代理对象")]),v._v("（JDK、CGLIB动态代理）")])])]),v._v(" "),_("li",[_("p",[v._v("销毁")]),v._v(" "),_("ol",[_("li",[v._v("调用销毁生命周期回调（PreDestroy(常用) 、destroy() 、destroy-method）")])])])]),v._v(" "),_("h2",{attrs:{id:"_7-spring中的循环引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-spring中的循环引用"}},[v._v("#")]),v._v(" 7. Spring中的循环引用？")]),v._v(" "),_("p",[v._v("循环依赖发生在两个或两个以上的bean互相持有对方，形成闭环。常见形式包括：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("直接循环依赖")]),v._v("：A 依赖 B，B 依赖 A。")]),v._v(" "),_("li",[_("strong",[v._v("间接循环依赖")]),v._v("：A 依赖 B，B 依赖 C，C 依赖 A。")]),v._v(" "),_("li",[_("strong",[v._v("自我依赖")]),v._v("：A 依赖 A（较少见）。")])]),v._v(" "),_("p",[v._v("Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题：")]),v._v(" "),_("ol",[_("li",[v._v("一级缓存：单例池，缓存已完成初始化的bean对象。")]),v._v(" "),_("li",[v._v("二级缓存：缓存尚未完成生命周期的早期bean对象。")]),v._v(" "),_("li",[v._v("三级缓存：缓存"),_("code",[v._v("ObjectFactory")]),v._v("，用于创建bean对象。")])]),v._v(" "),_("p",[v._v("构造器注入的循环依赖三级缓存无法解决，需使用注解@Lazy")]),v._v(" "),_("h3",{attrs:{id:"_8-那具体解决流程清楚吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-那具体解决流程清楚吗"}},[v._v("#")]),v._v(" 8. 那具体解决流程清楚吗？")]),v._v(" "),_("p",[v._v("解决循环依赖的流程如下：")]),v._v(" "),_("ol",[_("li",[v._v("实例化A对象，并创建"),_("code",[v._v("ObjectFactory")]),v._v("存入三级缓存。")]),v._v(" "),_("li",[v._v("A在初始化时需要B对象，开始B的创建逻辑。")]),v._v(" "),_("li",[v._v("B实例化完成，也创建"),_("code",[v._v("ObjectFactory")]),v._v("存入三级缓存。")]),v._v(" "),_("li",[v._v("B需要注入A，通过三级缓存获取"),_("code",[v._v("ObjectFactory")]),v._v("生成A对象，存入二级缓存。")]),v._v(" "),_("li",[v._v("B通过二级缓存获得A对象后，B创建成功，存入一级缓存。")]),v._v(" "),_("li",[v._v("A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。")]),v._v(" "),_("li",[v._v("清除二级缓存中的临时对象A。")])]),v._v(" "),_("h3",{attrs:{id:"_9-构造方法出现了循环依赖怎么解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-构造方法出现了循环依赖怎么解决"}},[v._v("#")]),v._v(" 9. 构造方法出现了循环依赖怎么解决？")]),v._v(" "),_("p",[v._v("由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。可以使用"),_("code",[v._v("@Lazy")]),v._v("懒加载注解，延迟bean的创建直到实际需要时。")]),v._v(" "),_("h2",{attrs:{id:"_12-spring-的常见注解有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-spring-的常见注解有哪些"}},[v._v("#")]),v._v(" 12. Spring 的常见注解有哪些？")]),v._v(" "),_("p",[v._v("Spring的常见注解包括：")]),v._v(" "),_("ol",[_("li",[v._v("声明Bean的注解："),_("code",[v._v("@Component")]),v._v("、"),_("code",[v._v("@Service")]),v._v("、"),_("code",[v._v("@Repository")]),v._v("、"),_("code",[v._v("@Controller")]),v._v("。")]),v._v(" "),_("li",[v._v("依赖注入相关注解："),_("code",[v._v("@Autowired")]),v._v("、"),_("code",[v._v("@Qualifier")]),v._v("。")]),v._v(" "),_("li",[v._v("设置作用域的注解："),_("code",[v._v("@Scope")]),v._v("。")]),v._v(" "),_("li",[v._v("配置相关注解："),_("code",[v._v("@Configuration")]),v._v("、"),_("code",[v._v("@ComponentScan")]),v._v("、"),_("code",[v._v("@Bean")]),v._v("。")]),v._v(" "),_("li",[v._v("AOP相关注解："),_("code",[v._v("@Aspect")]),v._v("、"),_("code",[v._v("@Before")]),v._v("、"),_("code",[v._v("@After")]),v._v("、"),_("code",[v._v("@Around")]),v._v("、"),_("code",[v._v("@Pointcut")]),v._v("。")])]),v._v(" "),_("h3",{attrs:{id:"autowired和-resource的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#autowired和-resource的区别"}},[v._v("#")]),v._v(" @Autowired和@Resource的区别")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("@Autowired是Spring提供的注解，默认根据类型注入，")])]),v._v(" "),_("li",[_("p",[v._v("@Autowired有一个属性required，默认为true，表示强制要求bean实例的注入，在项目启动时，如果在IOC容器中没有对应类型的Bean就会报错，如果不想要自动注入，也可以设置为false。")])]),v._v(" "),_("li",[_("p",[v._v("但IOC容器中有多个相同类型的Bean，由于@Autowired注解时根据类型注入bean的，所以会报错，可以用@Primary、@Qualifier注解解决，")]),v._v(" "),_("ul",[_("li",[v._v("@Primary是指定主要的bean，当有多个相同类型的bean时，会优先使用声明了@Primary注解的bean。")]),v._v(" "),_("li",[v._v("而使用@Qualifier可以根据bean的名字去装配")])])]),v._v(" "),_("li",[_("p",[v._v("@Resource是JDK提供的注解，Spring提供了对这个注解的支持，")])]),v._v(" "),_("li",[_("p",[v._v("@Resource可以通过属性name和type指定注入bean的方式，使用name可以根据bean的名字注入，type可以根据类型注入，如果都不指定，默认是根据名字注入，如果没有匹配成功，再通过类型注入，如果两个都没有匹配到的话，就会报错。")])]),v._v(" "),_("li",[_("p",[v._v("总结：")]),v._v(" "),_("ul",[_("li",[v._v("@Autowired是spring提供的注解。@Resource是jdk提供的注解，只是spring提供了对这个注解的支持。")]),v._v(" "),_("li",[v._v("@Autowired默认根据类型注入bean，如果有多个相同类型的bean，可以通过@Primary、@Qualifier注解来解决。而@Resource可以指定通过名字或者类型来注入bean。默认是根据bean的名字注入，如果没有匹配到，再根据类型注入。")])])])]),v._v(" "),_("h3",{attrs:{id:"component和-bean的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#component和-bean的区别"}},[v._v("#")]),v._v(" @Component和@Bean的区别")]),v._v(" "),_("p",[v._v("用途：")]),v._v(" "),_("ul",[_("li",[v._v("@Component适用于标注一个普通类")]),v._v(" "),_("li",[v._v("@Bean注解是在配置类的方法上声明和配置一个定制化的Bean对象")])]),v._v(" "),_("p",[v._v("使用方式：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("@Component是一个类级别的注解，Spring通过@ComponentScan注解扫描修饰了@Component注解的类并注册到SpringIOC容器中为Bean")])]),v._v(" "),_("li",[_("p",[v._v("@Bean是方法级别的注解，在带有@Configuration注解的配置类中手动声明和配置Bean")])])]),v._v(" "),_("p",[v._v("控制权：")]),v._v(" "),_("ul",[_("li",[v._v("@Component注解修饰的类是由Spring框架来创建和初始化的")]),v._v(" "),_("li",[v._v("@Bean注解允许开发人员手动控制Bean的创建和配置过程")])]),v._v(" "),_("h3",{attrs:{id:"bean-在-component-和-configuration-中的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bean-在-component-和-configuration-中的区别"}},[v._v("#")]),v._v(" @Bean 在 @Component 和 @Configuration 中的区别")]),v._v(" "),_("ul",[_("li",[_("strong",[_("code",[v._v("@Bean")]),v._v(" 在 "),_("code",[v._v("@Component")]),v._v(" 中")]),v._v("`\n"),_("ul",[_("li",[_("code",[v._v("@Bean")]),v._v(" 方法会被当作普通的工厂方法调用，每次调用都会返回一个新的实例。")]),v._v(" "),_("li",[v._v("不支持 "),_("code",[v._v("@Bean")]),v._v(" 方法之间的依赖注入（通过方法调用）。")])])]),v._v(" "),_("li",[_("strong",[_("code",[v._v("@Bean")]),v._v(" 在 "),_("code",[v._v("@Configuration")]),v._v(" 中")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("@Bean")]),v._v(" 方法会被 Spring 代理，确保\t每次调用返回的是同一个实例（单例）。")]),v._v(" "),_("li",[v._v("支持 "),_("code",[v._v("@Bean")]),v._v(" 方法之间的依赖注入（通过方法调用）。")])])])]),v._v(" "),_("h3",{attrs:{id:"如何给bean指定名称"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何给bean指定名称"}},[v._v("#")]),v._v(" 如何给bean指定名称")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("方法")]),v._v(" "),_("th",[v._v("示例代码")]),v._v(" "),_("th",[v._v("适用场景")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v('@Component("name")')])]),v._v(" "),_("td",[_("code",[v._v('@Component("myBean")')])]),v._v(" "),_("td",[v._v("自动扫描组件时指定名称")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v('@Bean(name = "name")')])]),v._v(" "),_("td",[_("code",[v._v('@Bean(name = "customBean")')])]),v._v(" "),_("td",[v._v("在配置类中手动定义Bean时指定名称")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v('@Qualifier("name")')])]),v._v(" "),_("td",[_("code",[v._v('@Qualifier("primaryService")')])]),v._v(" "),_("td",[v._v("解决多Bean冲突时指定限定符")])]),v._v(" "),_("tr",[_("td",[v._v("XML "),_("code",[v._v('<bean id="name">')])]),v._v(" "),_("td",[_("code",[v._v('<bean id="myBean">')])]),v._v(" "),_("td",[v._v("使用XML配置时指定名称")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v('@Named("name")')])]),v._v(" "),_("td",[_("code",[v._v('@Named("customName")')])]),v._v(" "),_("td",[v._v("使用JSR-330标准时指定名称")])])])]),v._v(" "),_("h3",{attrs:{id:"async-为什么不建议用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#async-为什么不建议用"}},[v._v("#")]),v._v(" @Async 为什么不建议用？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("默认线程池的弊端")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("线程无复用：默认使用SimpleAsyncTaskExecutor，每次调用都会创建新线程，而非复用线程池中的线程，可能导致系统资源耗尽（如内存溢出）")])]),v._v(" "),_("li",[_("p",[v._v("缺乏流量控制：默认配置下线程数无上限(Integer.MAX_VALUE),高并发时可能引发性能问题。")])])])]),v._v(" "),_("li",[_("p",[v._v("异常处理困难")]),v._v(" "),_("ul",[_("li",[v._v("异步方法抛出的异常不会直接传递给调用方，需通过AsyncUncaughtExceptionHandler或Future.get()捕获，增加了调试复杂度")])])]),v._v(" "),_("li",[_("p",[v._v("事务与上下文问题")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("事务上下文默认不会传递到异步方法中，可能导致事务失效")])]),v._v(" "),_("li",[_("p",[v._v("自调用（同类方法调用@Asyc方法）因代理机制失效，无法异步执行")])])])]),v._v(" "),_("li",[_("p",[v._v("性能与稳定性风险")]),v._v(" "),_("ul",[_("li",[v._v("线程阻塞：若异步方法中包含阻塞操作（如IO)，可能会导致线程死锁")])])])]),v._v(" "),_("h2",{attrs:{id:"_10-springmvc的执行流程-视图阶段-jsp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-springmvc的执行流程-视图阶段-jsp"}},[v._v("#")]),v._v(" 10. SpringMVC的执行流程？视图阶段（JSP）")]),v._v(" "),_("p",[v._v("SpringMVC的执行流程包括以下步骤：、")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:/Users/86157/Desktop/blog-img/img/image-20250405003249905.png",alt:"image-20250405003249905"}})]),v._v(" "),_("ol",[_("li",[v._v("用户发送出请求到前端控制器DispatcherServlet（DispatcherServlet是一个调度中心，负责调用其他的组件来完成用户的请求）")]),v._v(" "),_("li",[v._v("DispatcherServlet收到请求调用HandlerMapping(处理器映射器)")]),v._v(" "),_("li",[v._v("HandlerMapping找到具体的处理器，生成处理器对像及处理器拦截器（如果有），再一起返回给DispatcherServlet。")]),v._v(" "),_("li",[v._v("DispatcherServlet调用HandlerAdapter(处理器适配器)")]),v._v(" "),_("li",[v._v("HandlerAdapter经过适配调用具体的处理器(Handler/Controller)，Controller中的方法")]),v._v(" "),_("li",[v._v("Controller执行完成返回ModelAndView对象")]),v._v(" "),_("li",[v._v("HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet")]),v._v(" "),_("li",[v._v("DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)")]),v._v(" "),_("li",[v._v("ViewReslover解析后返回具体View(视图)")]),v._v(" "),_("li",[v._v("DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）")]),v._v(" "),_("li",[v._v("DispatcherServlet响应用户")])]),v._v(" "),_("h3",{attrs:{id:"springmvc的四大核心组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springmvc的四大核心组件"}},[v._v("#")]),v._v(" SpringMVC的四大核心组件")]),v._v(" "),_("ol",[_("li",[v._v("DispatcherServlet前端控制器，负责接收前端发来的所有请求，然后调用其他的三个组件处理用户请求")]),v._v(" "),_("li",[v._v("HandlerMapping处理器映射器，生成并返回handler处理器")]),v._v(" "),_("li",[v._v("HandlerAdapter处理器适配器，处理handler的参数和返回值")]),v._v(" "),_("li",[v._v("ViewReslover处理器解析器，将逻辑视图解析为具体视图，")])]),v._v(" "),_("h3",{attrs:{id:"springmvc的执行流程-前后端分离阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springmvc的执行流程-前后端分离阶段"}},[v._v("#")]),v._v(" SpringMVC的执行流程（前后端分离阶段）")]),v._v(" "),_("p",[_("img",{attrs:{src:"C:/Users/86157/Desktop/blog-img/img/image-20250405142844276.png",alt:"image-20250405142844276"}})]),v._v(" "),_("ol",[_("li",[v._v("用户发送出请求到前端控制器DispatcherServlet")]),v._v(" "),_("li",[v._v("DispatcherServlet收到请求调用HandlerMapping(处理器映射器)")]),v._v(" "),_("li",[v._v("HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给DispatcherServlet。")]),v._v(" "),_("li",[v._v("DispatcherServlet调用HandlerAdapter(处理器适配器)")]),v._v(" "),_("li",[v._v("HandlerAdapter经过适配调用具体的处理器(Handler/Controller)")]),v._v(" "),_("li",[v._v("由于方法上添加了@ResponseBody")]),v._v(" "),_("li",[v._v("处理器会通过HttpMessageConverter将返回结果转换为JSON并响应给用户")])]),v._v(" "),_("h3",{attrs:{id:"springmvc的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springmvc的理解"}},[v._v("#")]),v._v(" SpringMVC的理解")]),v._v(" "),_("p",[v._v("Spring MVC 是 "),_("strong",[v._v("Spring Framework")]),v._v(" 生态中的一个 "),_("strong",[v._v("Web 框架")]),v._v("，它基于 "),_("strong",[v._v("Servlet API")]),v._v(" 构建，采用 "),_("strong",[v._v("MVC（Model-View-Controller）")]),v._v(" 设计模式，旨在简化传统的 "),_("strong",[v._v("Servlet + JSP")]),v._v(" 开发方式。")]),v._v(" "),_("p",[v._v("Spring MVC 的架构增强与扩展")]),v._v(" "),_("p",[v._v("控制层（Controller）拆分")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("前端控制器（DispatcherServlet）")]),v._v("：负责请求的统一分发。")]),v._v(" "),_("li",[_("strong",[v._v("后端控制器（@Controller）")]),v._v("：处理具体业务逻辑。")])]),v._v(" "),_("p",[v._v("模型层（Model）分层")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("业务层（Service）")]),v._v("：处理业务逻辑。")]),v._v(" "),_("li",[_("strong",[v._v("数据访问层（Repository/Dao）")]),v._v("：负责数据库交互。")])]),v._v(" "),_("p",[v._v("视图层（View）灵活支持")]),v._v(" "),_("ul",[_("li",[v._v("支持多种视图技术，如 "),_("strong",[v._v("JSP、Thymeleaf、FreeMarker、Velocity")]),v._v(" 等。")])]),v._v(" "),_("p",[v._v("Spring MVC 的工作流程")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("请求进入 DispatcherServlet")]),v._v("（核心控制器）。")]),v._v(" "),_("li",[_("strong",[v._v("DispatcherServlet 匹配对应的 @Controller")]),v._v(" 处理请求。")]),v._v(" "),_("li",[_("strong",[v._v("Controller 处理业务逻辑")]),v._v("，返回 "),_("strong",[v._v("ModelAndView")]),v._v("（数据 + 视图名）。")]),v._v(" "),_("li",[_("strong",[v._v("DispatcherServlet 调用 ViewResolver")]),v._v("（视图解析器）解析视图。")]),v._v(" "),_("li",[_("strong",[v._v("渲染视图")]),v._v("，将数据展示到客户端。")])]),v._v(" "),_("h2",{attrs:{id:"_13-springmvc常见的注解有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-springmvc常见的注解有哪些"}},[v._v("#")]),v._v(" 13. SpringMVC常见的注解有哪些？")]),v._v(" "),_("p",[v._v("SpringMVC的常见注解有：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("@RequestMapping")]),v._v("：映射请求路径，用于类上，表示类中所有的方法都是以该地址为父路径。")]),v._v(" "),_("li",[_("code",[v._v("@RequestBody")]),v._v("：接收HTTP请求的JSON数据，将JSON转换为Java对象。")]),v._v(" "),_("li",[_("code",[v._v("@RequestParam")]),v._v("：指定请求路径的查询参数名称。")]),v._v(" "),_("li",[_("code",[v._v("@PathVariable")]),v._v("：从请求路径中获取参数。")]),v._v(" "),_("li",[_("code",[v._v("@ResponseBody")]),v._v("：将Controller方法返回的对象转化为JSON。")]),v._v(" "),_("li",[_("code",[v._v("@RequestHeader")]),v._v("：获取请求头数据。")]),v._v(" "),_("li",[_("code",[v._v("@RestController")]),v._v("="),_("code",[v._v("@ResponseBody")]),v._v(" + "),_("code",[v._v("@Controller")]),v._v("等。")])]),v._v(" "),_("h2",{attrs:{id:"_14-springboot常见注解有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-springboot常见注解有哪些"}},[v._v("#")]),v._v(" 14. Springboot常见注解有哪些？")]),v._v(" "),_("p",[v._v("Spring Boot的常见注解包括：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("@SpringBootApplication")]),v._v("：由"),_("code",[v._v("@SpringBootConfiguration")]),v._v("、"),_("code",[v._v("@EnableAutoConfiguration")]),v._v("和"),_("code",[v._v("@ComponentScan")]),v._v("组成。")]),v._v(" "),_("li",[_("code",[v._v("@SpringBootConfiguration")]),v._v("是组合了"),_("code",[v._v("@Configuration")])]),v._v(" "),_("li",[_("code",[v._v("@EnableAutoConfiguration")]),v._v("打开自动配置功能")])]),v._v(" "),_("h2",{attrs:{id:"过滤器和拦截器的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#过滤器和拦截器的区别"}},[v._v("#")]),v._v(" 过滤器和拦截器的区别")]),v._v(" "),_("p",[v._v("第一运行的顺序不同，过滤器是SURVELI容器接收到请求之后，但是在SURVILIZE被调用之前运行的，而拦截器呢则是在SURVILIZE被调用之后，但是在响应被发送到客户端之前来运行的，第二配置方式不同，过滤器是在web点XML里面进行配置，而拦截器是在spring的配置文件中去进行配置，或者使用注解的方式进行配置，第3filter呢依赖于SURVILIT容器，而interceptor不依赖于SURVIL的容器，第4filter在过滤器中，只能对request和response进行操作，而interceptor呢可以对request response，handle le mode and view exception进行操作，相当于in interceptor多了，对于spring mvc生态下的组件的一个操作能力")]),v._v(" "),_("p",[v._v("运行的顺序不同：")]),v._v(" "),_("ul",[_("li",[v._v("过滤器先执行，然后才执行拦截器")]),v._v(" "),_("li",[v._v("过滤器(Filter)是在Servlet容器接收到请求之后，但在Servlet被调用之前执行。\n拦截器(Interceptor)则是在Servlet被调用之后，但在响应被发送到客户端之前执行。")])]),v._v(" "),_("p",[v._v("依赖关系不同：")]),v._v(" "),_("ul",[_("li",[v._v("过滤器依赖于Servlet容器。")]),v._v(" "),_("li",[v._v("拦截器不依赖于Servlet容器，它是Spring框架的一部分。")])]),v._v(" "),_("p",[v._v("使用方式：")]),v._v(" "),_("ul",[_("li",[v._v("过滤器依赖servlet提供的fliter 接口，多个过滤器会根据配置的顺序来决定执行顺序")]),v._v(" "),_("li",[v._v("拦截器依赖Spring MVC提供的handlerInterceptor接口，多个拦截器根据Bean的配置顺序决定执行顺序，可以通过order来改变顺序")])]),v._v(" "),_("p",[v._v("用途：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("过滤器通常用来执行一些必要，编码处理、跨域处理")])]),v._v(" "),_("li",[_("p",[v._v("拦截器通常用来执行一些跟业务相关的，如身份认证与授权、日志记录")])])]),v._v(" "),_("p",[v._v("拦截器天然集成Spring，可以直接把Bean自动装配进来，方便执行业务处理")]),v._v(" "),_("h2",{attrs:{id:"依赖注入时推荐使用构造函数注入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入时推荐使用构造函数注入"}},[v._v("#")]),v._v(" 依赖注入时推荐使用构造函数注入")]),v._v(" "),_("p",[v._v("依赖注入的三种方式")]),v._v(" "),_("ol",[_("li",[v._v("使用"),_("code",[v._v("@Autowired")]),v._v("注解：将"),_("code",[v._v("@Autowired")]),v._v("注解直接标记在字段上，Spring会自动注入依赖。")]),v._v(" "),_("li",[v._v("Setter注入：使用"),_("code",[v._v("@Autowired")]),v._v("注解标记Setter方法，Spring会自动调用Setter方法注入依赖。")]),v._v(" "),_("li",[v._v("构造函数注入：如果有构造函数，Spring会自动调用构造函数并注入所需的依赖。")])]),v._v(" "),_("p",[v._v("为什么推荐使用构造函数注入？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("不可变性（Immutability）")]),v._v(" "),_("ul",[_("li",[v._v("构造函数注入允许将依赖字段声明为"),_("code",[v._v("final")]),v._v("，确保依赖在对象创建后不可变。")])])]),v._v(" "),_("li",[_("p",[v._v("确保依赖项不为null")]),v._v(" "),_("p",[v._v("构造函数注入强制要求在创建对象时提供所有依赖，如果依赖项不存在，编译器会报错")])]),v._v(" "),_("li",[_("p",[v._v("避免循环依赖")]),v._v(" "),_("p",[v._v("构造函数注入可以帮助发现循环依赖问题，因为Spring在启动时会检查构造函数注入的循环依赖。可以通过 "),_("code",[v._v("@Lazy")]),v._v("解决")])]),v._v(" "),_("li",[_("p",[v._v("符合单一职责原则")]),v._v(" "),_("p",[v._v("构造函数注入强制要求类的依赖在构造函数中明确声明，有助于遵循单一职责原则（SRP）。")])])]),v._v(" "),_("p",[v._v("使用构造函数时，当一个类只有一个构造函数时，Spring 会自动选择它进行注入，无需额外注解。如果有多个构造函数，需要使用 "),_("code",[v._v("@Autowired")]),v._v(" 或 "),_("code",[v._v("@Primary")]),v._v(" 明确指定。")]),v._v(" "),_("p",[v._v("如果需要添加注入的依赖，还需要修改构造函数，这时可以使用lombok工具的RequiredArgsConstructor，会自动注入被final修饰的字段")]),v._v(" "),_("h2",{attrs:{id:"spring通知有哪些类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring通知有哪些类型"}},[v._v("#")]),v._v(" Spring通知有哪些类型？")]),v._v(" "),_("h2",{attrs:{id:"解释基于xml-schema方式的切面实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解释基于xml-schema方式的切面实现"}},[v._v("#")]),v._v(" 解释基于XML Schema方式的切面实现")]),v._v(" "),_("h2",{attrs:{id:"解释基于注解的切面实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解释基于注解的切面实现"}},[v._v("#")]),v._v(" 解释基于注解的切面实现")]),v._v(" "),_("h2",{attrs:{id:"spring-aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop"}},[v._v("#")]),v._v(" Spring AOP")]),v._v(" "),_("h3",{attrs:{id:"jdk和cglib动态代理的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk和cglib动态代理的区别"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.bilibili.com/video/BV1LK421e7HD",target:"_blank",rel:"noopener noreferrer"}},[v._v("JDK和CGLIB动态代理的区别"),_("OutboundLink")],1)]),v._v(" "),_("ol",[_("li",[v._v("JDK动态代理只提供接口的代理，不支持类的代理。而CGLIB不用实现接口。当被代理的类实现了接口会默认使用jdk代理")]),v._v(" "),_("li",[v._v("JDK动态代理是通过字节码的方式生成的动态代理类，而CGLIB是用ASM的开源字节码生成库生成的代理类（还有其他的相关的类）")]),v._v(" "),_("li",[v._v("JDK动态代理是实现了目标类的接口，而CGLIB是将目标类作为父类进行继承，并重写父类的所有方法")]),v._v(" "),_("li",[v._v("调用时，JDK动态代理是通过反射调用的目标方法，而CGLIB是通过直接子类调用父类的方式调用目标方法")])]),v._v(" "),_("p",[v._v("其他")]),v._v(" "),_("ul",[_("li",[v._v("CGLIB是通过继承做的动态代理，所有如果类被标记为final，那么它是无法使用CGLIB做动态代理的。")]),v._v(" "),_("li",[v._v("CGLIB除了生成目标子类代理类，还有一个FastClass(路由类)，可以（但spring为了和jdk统一，默认没有使用）让本类方法调用进行增强（通过路由类回调代理类来实现方法的增强），而不会像jdk代理那样调用本类方法，增强会失效")]),v._v(" "),_("li",[v._v("JDK和CGLIB的性能：JDK动态代理生成类速度快调用慢，CGLIB生成类速度慢但后续调用快，在老版本CGLIB的速度是JDK速度的10倍左右，但是实际上JDK的速度在版本升级的时候每次都提高很多性能，而CGLIB仍止步不前。在对JDK动态代理与CGib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CG引ib要好20%左右。")]),v._v(" "),_("li",[v._v("实现了接口的bean不能用实现类的class对象来获取bean，只能通过其接口的class对象来获取bean（因为实现类不在IOC容器中，被代理拦截了）或者实现类名字（需要用接口接收）\n"),_("ul",[_("li",[v._v("IUserService bean = ioc.getBean(IUserService.class):")]),v._v(" "),_("li",[v._v('IUserService bean = (IUserService) ioc.getBean("userServiceImpl")；')])])])]),v._v(" "),_("h2",{attrs:{id:"spring事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring事务"}},[v._v("#")]),v._v(" Spring事务")]),v._v(" "),_("h3",{attrs:{id:"为什么有些公司禁止使用-transactional声明式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么有些公司禁止使用-transactional声明式事务"}},[v._v("#")]),v._v(" 为什么有些公司禁止使用@Transactional声明式事务？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("使用声明式事务，如果一个方法中存在较多耗时的操作，会引发长事务问题。长事务会导致锁的竞争，影响性能，也会占用数据库连接，导致数据库连接池被耗尽，影响程序正常执行。")])]),v._v(" "),_("li",[_("p",[v._v("@Transaction事务是通过spring的代理机制实现的，如果调用同类方法会导致事务失效。")])]),v._v(" "),_("li",[_("p",[v._v("@Transaction声明事务将事务控制逻辑放在注解中，如果项目复杂度增加，事务控制可能会变得复杂， 导致代码可读性和维护性下降，")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("// 反例：事务属性与业务逻辑混杂\n@Transactional(\n    isolation = ISOLATION_SERIALIZABLE,\n    timeout = 30,\n    rollbackFor = {BizException.class, DBException.class}\n)\n")])])])]),v._v(" "),_("li",[_("p",[v._v("@Transaction事务是方法层面的，事务范围是整个方法，而使用编程式事务可以更加灵活的控制事务范围，减少事务的锁定时间")])])]),v._v(" "),_("h3",{attrs:{id:"spring事务的实现方式和实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring事务的实现方式和实现原理"}},[v._v("#")]),v._v(" Spring事务的实现方式和实现原理")]),v._v(" "),_("h3",{attrs:{id:"spring的事务传播行为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务传播行为"}},[v._v("#")]),v._v(" Spring的事务传播行为")]),v._v(" "),_("p",[v._v("Spring的事务传播行为定义了Spring多个事务方法相互调用时事务的传播规则")]),v._v(" "),_("p",[v._v("Spring事务有七种传播行为。")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("REQUIRED（默认）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("如果当前存在事务，则加入该事务；否则新建一个事务。")])]),v._v(" "),_("li",[_("p",[v._v("适用场景：通用业务逻辑")])])])]),v._v(" "),_("li",[_("p",[v._v("REQUIRED_NEW")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("无论当前是否存在事务，都新建独立事务，原事务被挂起。")])]),v._v(" "),_("li",[_("p",[v._v("适用场景：需隔离的子任务")])])])]),v._v(" "),_("li",[_("p",[v._v("NESTED")]),v._v(" "),_("ul",[_("li",[v._v("若当前存在事务，则在嵌套事务（子事务）中执行，可独立回滚；否则新建事务。")]),v._v(" "),_("li",[v._v("适用场景：部分操作可回滚")])])]),v._v(" "),_("li",[_("p",[v._v("SUPPORTS")]),v._v(" "),_("ul",[_("li",[v._v("如果当前存在事务，则加入该事务，若不存在则以非事务方式执行。")]),v._v(" "),_("li",[v._v("适用场景：兼容无事务环境")])])]),v._v(" "),_("li",[_("p",[v._v("NOT_SUPPORTED")]),v._v(" "),_("ul",[_("li",[v._v("以非事务方式执行，若存在事务则挂起。")]),v._v(" "),_("li",[v._v("适用场景：非关键操作")])])]),v._v(" "),_("li",[_("p",[v._v("MANDATORY")]),v._v(" "),_("ul",[_("li",[v._v("如果当前存在事务，则加入该事务；否则抛出异常。")]),v._v(" "),_("li",[v._v("适用场景：强制事务执行")])])]),v._v(" "),_("li",[_("p",[v._v("NEVER")]),v._v(" "),_("ul",[_("li",[v._v("强制非事务执行，若存在事务则抛出异常。")]),v._v(" "),_("li",[v._v("适用场景：禁止事务调用的方法")])])])]),v._v(" "),_("h4",{attrs:{id:"在一个包含多个服务调用的业务流程中-如果其中一个服务方法执行失败应立即回滚-不影响其他服务的正常执行-你认为应如何设置事务传播行为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在一个包含多个服务调用的业务流程中-如果其中一个服务方法执行失败应立即回滚-不影响其他服务的正常执行-你认为应如何设置事务传播行为"}},[v._v("#")]),v._v(" 在一个包含多个服务调用的业务流程中，如果其中一个服务方法执行失败应立即回滚，不影响其他服务的正常执行，你认为应如何设置事务传播行为？")]),v._v(" "),_("p",[v._v("使用REQUIRED_NEW或者NESTED\nREQUIRED_NEW可以为每一个方法创建一个新的独立事务，不会相互影响，而NESTED是嵌套一个子事务，子事务会独立回滚，但是如果外层事务回滚，子事务也会回滚")]),v._v(" "),_("h4",{attrs:{id:"requires-new的实际应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#requires-new的实际应用"}},[v._v("#")]),v._v(" REQUIRES _NEW的实际应用")]),v._v(" "),_("p",[v._v("记录日志")]),v._v(" "),_("h4",{attrs:{id:"如果系统中出现了事务嵌套过深导致的性能问题你认为可能的原因是什么-如何优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果系统中出现了事务嵌套过深导致的性能问题你认为可能的原因是什么-如何优化"}},[v._v("#")]),v._v(" 如果系统中出现了事务嵌套过深导致的性能问题你认为可能的原因是什么？如何优化？")]),v._v(" "),_("p",[v._v("每个嵌套事务会占用独立的数据库连接，导致资源占用增加，或者事务持有的锁时间过长。优化：减少不必要的事务嵌套，将事务合并或者调整事务传播行为，优先使用REQUIRED代替REQUIRES_NEW，避免创建新的事务")]),v._v(" "),_("h3",{attrs:{id:"spring的事务隔离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务隔离"}},[v._v("#")]),v._v(" spring的事务隔离？")]),v._v(" "),_("h3",{attrs:{id:"spring框架的事务管理有哪些优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring框架的事务管理有哪些优点"}},[v._v("#")]),v._v(" Spring框架的事务管理有哪些优点？")]),v._v(" "),_("h2",{attrs:{id:"conditional注解的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#conditional注解的作用"}},[v._v("#")]),v._v(" conditional注解的作用")]),v._v(" "),_("p",[_("code",[v._v("@Conditional")]),v._v("注解的作用是"),_("strong",[v._v("为Bean的加载提供条件判断")]),v._v("，只有满足指定条件时，Spring才会将该Bean注册到IOC容器中。")]),v._v(" "),_("p",[v._v("而我们可以实现"),_("code",[v._v("Condition")]),v._v("接口，并重写"),_("code",[v._v("matches()")]),v._v("方法，编写自定义的条件判断逻辑。")]),v._v(" "),_("p",[v._v("所以conditional注解，增加了bean的装配的一个灵活性，")]),v._v(" "),_("p",[v._v("Spring Boot在"),_("code",[v._v("@Conditional")]),v._v("的基础上，提供了"),_("strong",[v._v("更语义化的条件注解")]),v._v("，避免手动编写"),_("code",[v._v("Condition")]),v._v("实现类：")]),v._v(" "),_("ul",[_("li",[_("strong",[_("code",[v._v("@ConditionalOnClass")])]),v._v("：当类路径中存在指定类时生效。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("@ConditionalOnBean")])]),v._v("：当容器中存在指定Bean时生效。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("@ConditionalOnProperty")])]),v._v("：当配置文件中存在指定属性且匹配值时生效。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("@ConditionalOnMissingBean")])]),v._v("：当容器中不存在指定Bean时生效。")])]),v._v(" "),_("h2",{attrs:{id:"spring里面的事物和分布式事务是如何区分的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring里面的事物和分布式事务是如何区分的"}},[v._v("#")]),v._v(" spring里面的事物和分布式事务是如何区分的")]),v._v(" "),_("p",[v._v("spring里没有提供事务，它只是提供了对数据库事务的一个管理的封装，我们可以通过声明式事务的配置啊，使得开发人员可以从一些复杂的事务处理，里面去脱离出来，我们不需要再去关心连接的获取啊，连接的关闭啊，事物的提交，事务的回滚，这样一些操作，我们可以更加聚焦在业务的开发层面，所以呢spring里面的事物啊，本质上是数据库层面的一个事物，而这种事务管理啊，主要是针对于单个数据库里面的，多个数据表的操作，他去满足一个事物的ACID特性，而分布事务呢是解决多个数据库事务操作的，一个数据一致性问题，传统的关系数据库呢不支持跨库的事务操作，所以需要引入分布式事务的解决方案，而spring里面并没有提供分布式事务的场景知识，所以spring里面的事物和分布式事务，在使用上并没有直接的关联关系，但是呢我们可以使用一些主流的分布式事务，解决框架，比如说像seata集成到spring生态里面去，解决分布式事务的一个问题")]),v._v(" "),_("p",[v._v("Spring 本身并不提供事务能力，而是对数据库事务的"),_("strong",[v._v("管理逻辑进行了封装")]),v._v("。通过声明式事务（如 "),_("code",[v._v("@Transactional")]),v._v("）的配置，开发者可以避免手动处理连接的获取/关闭、事务提交/回滚等底层操作，从而更专注于业务逻辑开发。")]),v._v(" "),_("ul",[_("li",[v._v("Spring 事务的本质是基于单个数据库的 ACID 特性（原子性、一致性、隔离性、持久性），用于管理"),_("strong",[v._v("同一数据库内")]),v._v("多个表的操作。")]),v._v(" "),_("li",[v._v("分布式事务用于协调"),_("strong",[v._v("多个独立数据库/服务")]),v._v("的事务操作（例如跨库、跨微服务），确保全局数据一致性。")])]),v._v(" "),_("p",[v._v("Spring 原生未提供分布式事务实现，但支持集成第三方框架（如 Seata、Atomikos）。例如，通过 Seata 的 "),_("code",[v._v("GlobalTransactional")]),v._v(" 注解，可以在 Spring 生态中实现分布式事务的协调（如 AT 模式、TCC 模式）。")]),v._v(" "),_("h2",{attrs:{id:"spring-中定义两个相同-id-的-bean-会报错吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-中定义两个相同-id-的-bean-会报错吗"}},[v._v("#")]),v._v(" Spring 中定义两个相同 ID 的 Bean 会报错吗？")]),v._v(" "),_("p",[v._v("在同一个XML配置文件里面，如果存在两个相同 ID 的 Bean，Spring 容器在启动时会直接报错（"),_("code",[v._v("BeanDefinitionStoreException")]),v._v("），因为 ID 是 Bean 的唯一标识符，")]),v._v(" "),_("p",[v._v("不同 XML 文件：")]),v._v(" "),_("ul",[_("li",[v._v("如果相同 ID 的 Bean 定义在"),_("strong",[v._v("不同的 XML 文件")]),v._v("中，Spring "),_("strong",[v._v("默认会覆盖")]),v._v("先加载的 Bean（后加载的生效）。")]),v._v(" "),_("li",[v._v("可通过 "),_("code",[v._v("allowBeanDefinitionOverriding=false")]),v._v(" 强制禁止覆盖，此时会报错。")])]),v._v(" "),_("p",[v._v("这时如果使用@Autowire注解，去根据类型进行实例注入，在启动时候会提示，找不到那个未注册的实例\n如果我们使用@Resource这个注解，去根据名字来实现依赖注入，而在spring IOC容器里，根据名字只会得到注册的那个实例对象，于是spring把这个实例赋值给那个未注册的实例时，会就提示类型不匹配错误，错误是在spring IOC容器里的bean初始化后，依赖注入阶段发生的")]),v._v(" "),_("h2",{attrs:{id:"spring中的bean的作用域有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中的bean的作用域有哪些"}},[v._v("#")]),v._v(" spring中的bean的作用域有哪些")]),v._v(" "),_("p",[v._v("常规的bean生命周期呢只有两种")]),v._v(" "),_("ol",[_("li",[v._v("Singleton（单例）整个 Spring 容器中只会存在一个 Bean 实例，所有请求共享同一个对象。默认作用域，适用于无状态的 Bean（如 Service、DAO）。")]),v._v(" "),_("li",[v._v("Prototype（原型）每次从 IOC 容器获取该 Bean 时，都会创建一个新的实例。适用于需要保持独立状态的 Bean（如 DTO、线程不安全对象）。")])]),v._v(" "),_("p",[v._v("在基于spring框架下的web应用里，增加了一个会话维度，来控制bean的生命周期，")]),v._v(" "),_("p",[_("strong",[v._v("Request（请求作用域）")])]),v._v(" "),_("ul",[_("li",[v._v("每次 HTTP 请求都会创建一个新的 Bean 实例，请求结束后销毁。")]),v._v(" "),_("li",[v._v("适用于存储请求级别的数据（如用户表单数据）。")])]),v._v(" "),_("p",[_("strong",[v._v("Session（会话作用域）")])]),v._v(" "),_("ul",[_("li",[v._v("同一个 HTTP Session 共享同一个 Bean 实例，不同 Session 使用不同的实例。")]),v._v(" "),_("li",[v._v("适用于存储用户会话数据（如登录信息）。")])]),v._v(" "),_("p",[_("strong",[v._v("Application / Global Session（全局会话作用域，仅 Portlet 应用）")])]),v._v(" "),_("ul",[_("li",[v._v("全局 Session 作用域，所有用户共享同一个 Bean 实例（已较少使用）")])]),v._v(" "),_("h2",{attrs:{id:"spring中的beanfactory-和factorybean-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中的beanfactory-和factorybean-的区别"}},[v._v("#")]),v._v(" spring中的BeanFactory 和FactoryBean 的区别")]),v._v(" "),_("p",[v._v("Spring的核心功能是IOC容器，IOC容器本质上是一个Bean的容器或者说是一个Bean的工厂。它能够根据XML配置或注解声明，完成Bean的加载和初始化，并生产所需的bean")]),v._v(" "),_("p",[v._v("BeanFactory")]),v._v(" "),_("ul",[_("li",[v._v("BeanFactory是Spring框架中所有Bean容器的顶级接口")]),v._v(" "),_("li",[v._v("它为Spring容器定义了一套完整的规范")]),v._v(" "),_("li",[v._v("提供了getBean()等基础方法，用于从容器中获取指定Bean实例")]),v._v(" "),_("li",[v._v("实现了依赖注入(DI)功能，解决Bean之间的依赖关系")])]),v._v(" "),_("p",[v._v("而FactoryBean")]),v._v(" "),_("ul",[_("li",[v._v("FactoryBean是一个特殊的工厂Bean，它是一个接口，主要用于动态生成特定类型的Bean实例，也就是用户自定义Bean的创建")]),v._v(" "),_("li",[v._v("有一个重要的方法getObject()，用于实现自定义的Bean构建过程")]),v._v(" "),_("li",[v._v("常用于创建复杂对象或需要特殊初始化的Bean")]),v._v(" "),_("li",[v._v("springCloud里的OpenFeign组件的客户端代理，就是使用FactoryBean来实现的")])])])}),[],!1,null,null,null);_.default=a.exports}}]);