(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{414:function(a,e,r){"use strict";r.r(e);var l=r(0),v=Object(l.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"谈谈你对threadlocal的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对threadlocal的理解"}},[a._v("#")]),a._v(" 谈谈你对ThreadLocal的理解")]),a._v(" "),e("p",[a._v("ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享")]),a._v(" "),e("h2",{attrs:{id:"threadlocal的底层原理实现吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal的底层原理实现吗"}},[a._v("#")]),a._v(" ThreadLocal的底层原理实现吗？")]),a._v(" "),e("p",[a._v("在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象")]),a._v(" "),e("p",[a._v("当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中")]),a._v(" "),e("p",[a._v("当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值")]),a._v(" "),e("p",[a._v("当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值")]),a._v(" "),e("h2",{attrs:{id:"threadlocal会导致内存溢出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal会导致内存溢出"}},[a._v("#")]),a._v(" ThreadLocal会导致内存溢出")]),a._v(" "),e("p",[a._v("是因为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。")]),a._v(" "),e("p",[a._v("在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。")]),a._v(" "),e("h2",{attrs:{id:"threadlocal有哪些使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal有哪些使用场景"}},[a._v("#")]),a._v(" ThreadLocal有哪些使用场景")]),a._v(" "),e("p",[a._v("ThreadLocal是一种多线程隔离机制，通过多线程环境下对共享变量的副本存储，解决了线程安全问题，避免了多线程竞争加锁的开销。其使用场景包括：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("线程的上下文传递")]),a._v(" "),e("ul",[e("li",[a._v("在处理请求的过程中保持用户特定的数据（如用户的登录信息）。通过 "),e("code",[a._v("ThreadLocal")]),a._v(" 可以方便地在同一个线程内的不同方法调用之间共享这些数据，而不用担心线程安全问题。")])])]),a._v(" "),e("li",[e("p",[a._v("数据库连接管理")]),a._v(" "),e("ul",[e("li",[a._v("在多线程应用中，每个线程可以使用 "),e("code",[a._v("ThreadLocal")]),a._v(" 来独立管理自己的数据库连接，避免线程之间的竞争与冲突。如mybatis的sqlsession")])])]),a._v(" "),e("li",[e("p",[a._v("事务管理等")]),a._v(" "),e("ul",[e("li",[a._v("使用 "),e("code",[a._v("ThreadLocal")]),a._v(" 可以让每个线程拥有独立的事务上下文，保证事务的隔离性。Spring 的 "),e("code",[a._v("TransactionSynchronizationManager")]),a._v(" 就使用 "),e("code",[a._v("ThreadLocal")]),a._v(" 来存储当前线程的事务资源（如数据库连接）。")])])])]),a._v(" "),e("p",[a._v("在使用ThreadLocall时，需要注意避免内存泄漏的问题。")]),a._v(" "),e("h2",{attrs:{id:"保证线程安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#保证线程安全"}},[a._v("#")]),a._v(" 保证线程安全")]),a._v(" "),e("ul",[e("li",[a._v("在方法内使用，局部变量则是线程安全的")]),a._v(" "),e("li",[a._v("使用线程安全的ArrayList和LinkedList")])])])}),[],!1,null,null,null);e.default=v.exports}}]);