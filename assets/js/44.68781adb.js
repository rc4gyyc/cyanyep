(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{411:function(v,t,a){"use strict";a.r(t);var _=a(0),r=Object(_.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"synchronized关键字的底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized关键字的底层原理"}},[v._v("#")]),v._v(" synchronized关键字的底层原理")]),v._v(" "),t("p",[v._v("synchronized 底层使用的 JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能获得到锁的。")]),v._v(" "),t("p",[v._v("synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。")]),v._v(" "),t("p",[v._v("monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因")]),v._v(" "),t("p",[v._v("monitor内部维护了三个变量")]),v._v(" "),t("ul",[t("li",[v._v("WaitSet：保存处于Waiting状态的线程")]),v._v(" "),t("li",[v._v("EntryList：保存处于Blocked状态的线程")]),v._v(" "),t("li",[v._v("Owner：持有锁的线程")])]),v._v(" "),t("p",[v._v("只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner")]),v._v(" "),t("p",[v._v("在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。")]),v._v(" "),t("p",[v._v("waitset关联的是处于在执行过程中进入Waiting状态的线程")]),v._v(" "),t("h3",{attrs:{id:"synchronized和lock的区别⭐⭐⭐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized和lock的区别⭐⭐⭐"}},[v._v("#")]),v._v(" synchronized和lock的区别⭐⭐⭐")]),v._v(" "),t("p",[v._v("第一，语法层面")]),v._v(" "),t("ul",[t("li",[v._v("synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放")]),v._v(" "),t("li",[v._v("Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁")])]),v._v(" "),t("p",[v._v("第二，功能层面")]),v._v(" "),t("ul",[t("li",[v._v("二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能")]),v._v(" "),t("li",[v._v("Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock")])]),v._v(" "),t("p",[v._v("第三，性能层面")]),v._v(" "),t("ul",[t("li",[v._v("在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖")]),v._v(" "),t("li",[v._v("Lock 是自旋锁的实现，在竞争激烈时，通常会提供更好的性能")])]),v._v(" "),t("p",[v._v("统合来看，需要根据不同的场景来选择不同的锁的使用。")]),v._v(" "),t("h3",{attrs:{id:"jmm-java-内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java-内存模型"}},[v._v("#")]),v._v(" JMM（Java 内存模型）")]),v._v(" "),t("p",[v._v("Java内存模型是Java虚拟机规范中定义的一种非常重要的内存模型。它的主要作用是描述Java程序中线程共享变量的访问规则，以及这些变量在JVM中是如何被存储和读取的，涉及到一些底层的细节。")]),v._v(" "),t("p",[v._v("这个模型有几个核心的特点。首先，所有的共享变量，包括实例变量和类变量，都被存储在主内存中，也就是计算机的RAM。需要注意的是，局部变量并不包含在内，因为它们是线程私有的，所以不存在竞争问题。")]),v._v(" "),t("p",[v._v("其次，每个线程都有自己的工作内存，这里保留了线程所使用的变量的工作副本。这意味着，线程对变量的所有操作，无论是读还是写，都必须在自己的工作内存中完成，而不能直接读写主内存中的变量。")]),v._v(" "),t("p",[v._v("最后，不同线程之间不能直接访问对方工作内存中的变量。如果线程间需要传递变量的值，那么这个过程必须通过主内存来完成。")]),v._v(" "),t("h3",{attrs:{id:"cas"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[v._v("#")]),v._v(" CAS")]),v._v(" "),t("p",[v._v("CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。")]),v._v(" "),t("ul",[t("li",[v._v("CAS使用到的地方很多：AQS框架、AtomicXXX类")]),v._v(" "),t("li",[v._v("在操作共享变量的时候使用的自旋锁，效率上更高一些")]),v._v(" "),t("li",[v._v("CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现")])]),v._v(" "),t("h4",{attrs:{id:"乐观锁和悲观锁的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁和悲观锁的区别"}},[v._v("#")]),v._v(" 乐观锁和悲观锁的区别")]),v._v(" "),t("p",[v._v("乐观锁（如CAS）：最乐观的估计，总是假设没有别的线程来修改共享变量，所以不上锁，在最后才查看共享变量有没有被修改，就算改了就通过自旋重试。")]),v._v(" "),t("p",[v._v("悲观锁（如synchronized）：最悲观的估计，总是上锁防着其他线程来修改共享变量，改完了解开锁，其他线程才有机会修改。")]),v._v(" "),t("h3",{attrs:{id:"请谈谈你对-volatile-的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请谈谈你对-volatile-的理解"}},[v._v("#")]),v._v(" 请谈谈你对 volatile 的理解")]),v._v(" "),t("p",[v._v("volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能")]),v._v(" "),t("p",[v._v("第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。")]),v._v(" "),t("p",[v._v("第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个"),t("strong",[v._v("内存屏障")]),v._v("，通过插入内存屏障禁止在内存屏障"),t("strong",[v._v("前后")]),v._v("的指令执行重排序优化")]),v._v(" "),t("h3",{attrs:{id:"什么是aqs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是aqs"}},[v._v("#")]),v._v(" 什么是AQS？")]),v._v(" "),t("p",[v._v("AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。")]),v._v(" "),t("p",[v._v("内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态")]),v._v(" "),t("p",[v._v("在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中")]),v._v(" "),t("ul",[t("li",[v._v("tail 指向队列最后一个元素")]),v._v(" "),t("li",[v._v("head  指向队列中最久的一个元素")])]),v._v(" "),t("p",[v._v("其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。")]),v._v(" "),t("h3",{attrs:{id:"reentrantlock的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock的实现原理"}},[v._v("#")]),v._v(" ReentrantLock的实现原理")]),v._v(" "),t("p",[v._v("ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。")]),v._v(" "),t("p",[v._v("ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。")]),v._v(" "),t("p",[v._v("它的底层实现原理主要利用"),t("strong",[v._v("CAS+AQS队列")]),v._v("来实现。它支持公平锁和非公平锁，两者的实现类似")]),v._v(" "),t("p",[v._v("构造方法接受一个可选的公平参数（"),t("strong",[v._v("默认非公平锁")]),v._v("），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。")]),v._v(" "),t("h3",{attrs:{id:"死锁产生的条件是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的条件是什么"}},[v._v("#")]),v._v(" 死锁产生的条件是什么")]),v._v(" "),t("p",[v._v("一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：")]),v._v(" "),t("p",[v._v("t1 线程获得A对象锁，接下来想获取B对象的锁")]),v._v(" "),t("p",[v._v("t2 线程获得B对象锁，接下来想获取A对象的锁")]),v._v(" "),t("p",[v._v("这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁")]),v._v(" "),t("h3",{attrs:{id:"如何进行死锁诊断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何进行死锁诊断"}},[v._v("#")]),v._v(" 如何进行死锁诊断？")]),v._v(" "),t("p",[v._v("我们只需要通过jdk自动的工具就能搞定")]),v._v(" "),t("p",[v._v("我们可以先通过"),t("strong",[v._v("jps")]),v._v("来查看当前java程序运行的进程id")]),v._v(" "),t("p",[v._v("然后通过"),t("strong",[v._v("jstack")]),v._v("来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。")]),v._v(" "),t("h3",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[v._v("#")]),v._v(" ConcurrentHashMap")]),v._v(" "),t("p",[v._v("ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。")]),v._v(" "),t("ul",[t("li",[v._v("JDK1.7的底层采用是"),t("strong",[v._v("分段的数组")]),v._v("+"),t("strong",[v._v("链表")]),v._v(" 实现")]),v._v(" "),t("li",[v._v("JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。")])]),v._v(" "),t("p",[v._v("在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。")]),v._v(" "),t("p",[v._v("Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁")]),v._v(" "),t("p",[v._v("在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升")]),v._v(" "),t("h3",{attrs:{id:"导致并发程序出现问题的根本原因是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#导致并发程序出现问题的根本原因是什么"}},[v._v("#")]),v._v(" 导致并发程序出现问题的根本原因是什么")]),v._v(" "),t("p",[v._v("Java并发编程有三大核心特性，分别是原子性、可见性和有序性。")]),v._v(" "),t("p",[v._v("首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。")]),v._v(" "),t("p",[v._v("其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。")]),v._v(" "),t("p",[v._v("最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。")])])}),[],!1,null,null,null);t.default=r.exports}}]);