(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{417:function(a,_,v){"use strict";v.r(_);var t=v(0),r=Object(t.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"_1-kafka是如何保证消息不丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-kafka是如何保证消息不丢失"}},[a._v("#")]),a._v(" 1. Kafka是如何保证消息不丢失？")]),a._v(" "),_("p",[a._v("Kafka保证消息不丢失的措施包括：")]),a._v(" "),_("ol",[_("li",[a._v("生产者使用异步回调发送消息，设置重试机制应对网络问题。")]),a._v(" "),_("li",[a._v("在Broker中通过复制机制，设置"),_("code",[a._v("acks")]),a._v("参数为"),_("code",[a._v("all")]),a._v("，确保消息在所有副本中都得到确认。")]),a._v(" "),_("li",[a._v("消费者手动提交消费成功的offset，避免自动提交可能导致的数据丢失或重复消费。")])]),a._v(" "),_("h2",{attrs:{id:"_2-kafka中消息的重复消费问题如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-kafka中消息的重复消费问题如何解决"}},[a._v("#")]),a._v(" 2. Kafka中消息的重复消费问题如何解决？")]),a._v(" "),_("p",[a._v("通过以下方法解决Kafka中的重复消费问题：")]),a._v(" "),_("ul",[_("li",[a._v("禁用自动提交offset，手动控制offset提交时机。")]),a._v(" "),_("li",[a._v("确保消息消费的幂等性，例如通过唯一主键或分布式锁。")])]),a._v(" "),_("h2",{attrs:{id:"_3-kafka是如何保证消费的顺序性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-kafka是如何保证消费的顺序性"}},[a._v("#")]),a._v(" 3. Kafka是如何保证消费的顺序性？")]),a._v(" "),_("p",[a._v("Kafka默认不保证消息顺序性，但可以通过以下方法实现：")]),a._v(" "),_("ul",[_("li",[a._v("将消息存储在同一个分区，通过指定分区号或相同的业务key来实现。")])]),a._v(" "),_("h2",{attrs:{id:"_4-kafka的高可用机制了解吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-kafka的高可用机制了解吗"}},[a._v("#")]),a._v(" 4. Kafka的高可用机制了解吗？")]),a._v(" "),_("p",[a._v("Kafka的高可用性主要通过以下机制实现：")]),a._v(" "),_("ul",[_("li",[a._v("集群部署，多broker实例，单点故障不影响整体服务。")]),a._v(" "),_("li",[a._v("复制机制，每个分区有多个副本，leader和follower，leader故障时从follower中选举新leader。")])]),a._v(" "),_("h2",{attrs:{id:"_5-解释一下复制机制中的isr"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-解释一下复制机制中的isr"}},[a._v("#")]),a._v(" 5. 解释一下复制机制中的ISR？")]),a._v(" "),_("p",[a._v("ISR（In-Sync Replicas）指与leader保持同步的follower副本。")]),a._v(" "),_("ul",[_("li",[a._v("当leader故障时，优先从ISR中选举新leader，因为它们数据一致性更高。")])]),a._v(" "),_("h2",{attrs:{id:"_6-kafka数据清理机制了解吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-kafka数据清理机制了解吗"}},[a._v("#")]),a._v(" 6. Kafka数据清理机制了解吗？")]),a._v(" "),_("p",[a._v("Kafka的数据清理包括：")]),a._v(" "),_("ul",[_("li",[a._v("基于消息保留时间的清理。")]),a._v(" "),_("li",[a._v("基于topic数据大小的清理，可配置删除最旧消息。")])]),a._v(" "),_("h2",{attrs:{id:"_7-kafka中实现高性能的设计有了解过吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-kafka中实现高性能的设计有了解过吗"}},[a._v("#")]),a._v(" 7. Kafka中实现高性能的设计有了解过吗？")]),a._v(" "),_("p",[a._v("Kafka高性能设计包括：")]),a._v(" "),_("ul",[_("li",[a._v("消息分区，提升数据处理能力。")]),a._v(" "),_("li",[a._v("顺序读写，提高磁盘操作效率。")]),a._v(" "),_("li",[a._v("页缓存，减少磁盘访问。")]),a._v(" "),_("li",[a._v("零拷贝，减少数据拷贝和上下文切换。")]),a._v(" "),_("li",[a._v("消息压缩，减少IO负载。")]),a._v(" "),_("li",[a._v("分批发送，降低网络开销。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);