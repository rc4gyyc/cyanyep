(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{515:function(v,_,t){"use strict";t.r(_);var a=t(1),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"同步调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步调用"}},[v._v("#")]),v._v(" 同步调用")]),v._v(" "),_("p",[v._v("目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：")]),v._v(" "),_("ul",[_("li",[v._v("支付服务需要先调用用户服务完成余额扣减")]),v._v(" "),_("li",[v._v("然后支付服务自己要更新支付流水单的状态")]),v._v(" "),_("li",[v._v("然后支付服务调用交易服务，更新业务订单状态为已支付")])]),v._v(" "),_("p",[v._v("三个步骤依次执行。")]),v._v(" "),_("p",[v._v("这其中就存在3个问题：")]),v._v(" "),_("p",[_("strong",[v._v("第一")]),v._v("，"),_("strong",[v._v("拓展性差")])]),v._v(" "),_("p",[v._v("我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。")]),v._v(" "),_("p",[v._v("在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？")]),v._v(" "),_("p",[v._v("某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？")]),v._v(" "),_("p",[v._v("。。。")]),v._v(" "),_("p",[v._v("最终你的支付业务会越来越臃肿")]),v._v(" "),_("p",[v._v("也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。")]),v._v(" "),_("p",[_("strong",[v._v("第二")]),v._v("，"),_("strong",[v._v("性能下降")])]),v._v(" "),_("p",[v._v("由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：")]),v._v(" "),_("p",[v._v("假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。")]),v._v(" "),_("p",[_("strong",[v._v("第三，级联失败")])]),v._v(" "),_("p",[v._v("由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。")]),v._v(" "),_("p",[v._v("这其实就是同步调用的"),_("strong",[v._v("级联失败")]),v._v("问题。")]),v._v(" "),_("p",[v._v("但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧。")]),v._v(" "),_("p",[v._v("因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。")]),v._v(" "),_("p",[v._v("综上，同步调用的方式存在下列问题：")]),v._v(" "),_("ul",[_("li",[v._v("拓展性差")]),v._v(" "),_("li",[v._v("性能下降")]),v._v(" "),_("li",[v._v("级联失败")])]),v._v(" "),_("p",[v._v("而要解决这些问题，我们就必须用"),_("strong",[v._v("异步调用")]),v._v("的方式来代替"),_("strong",[v._v("同步调用")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"异步调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步调用"}},[v._v("#")]),v._v(" 异步调用")]),v._v(" "),_("p",[v._v("异步调用方式其实就是基于消息通知的方式，一般包含三个角色：")]),v._v(" "),_("ul",[_("li",[v._v("消息发送者：投递消息的人，就是原来的调用方")]),v._v(" "),_("li",[v._v("消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器")]),v._v(" "),_("li",[v._v("消息接收者：接收和处理消息的人，就是原来的服务提供方")])]),v._v(" "),_("p",[v._v("在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。")]),v._v(" "),_("p",[v._v("这样，发送消息的人和接收消息的人就完全解耦了。")]),v._v(" "),_("p",[v._v("综上，异步调用的优势包括：")]),v._v(" "),_("ul",[_("li",[v._v("耦合度更低")]),v._v(" "),_("li",[v._v("性能更好")]),v._v(" "),_("li",[v._v("业务拓展性强")]),v._v(" "),_("li",[v._v("故障隔离，避免级联失败")])]),v._v(" "),_("p",[v._v("当然，异步通信也并非完美无缺，它存在下列缺点：")]),v._v(" "),_("ul",[_("li",[v._v("完全依赖于Broker的可靠性、安全性和性能")]),v._v(" "),_("li",[v._v("架构复杂，后期维护和调试麻烦")])]),v._v(" "),_("h2",{attrs:{id:"技术选型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#技术选型"}},[v._v("#")]),v._v(" 技术选型")]),v._v(" "),_("p",[v._v("消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.")]),v._v(" "),_("p",[v._v("目比较常见的MQ实现：")]),v._v(" "),_("ul",[_("li",[v._v("ActiveMQ")]),v._v(" "),_("li",[v._v("RabbitMQ")]),v._v(" "),_("li",[v._v("RocketMQ")]),v._v(" "),_("li",[v._v("Kafka")])]),v._v(" "),_("p",[v._v("几种常见MQ的对比：")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th"),v._v(" "),_("th",[v._v("RabbitMQ")]),v._v(" "),_("th",[v._v("ActiveMQ")]),v._v(" "),_("th",[v._v("RocketMQ")]),v._v(" "),_("th",[v._v("Kafka")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("公司/社区")]),v._v(" "),_("td",[v._v("Rabbit")]),v._v(" "),_("td",[v._v("Apache")]),v._v(" "),_("td",[v._v("阿里")]),v._v(" "),_("td",[v._v("Apache")])]),v._v(" "),_("tr",[_("td",[v._v("开发语言")]),v._v(" "),_("td",[v._v("Erlang")]),v._v(" "),_("td",[v._v("Java")]),v._v(" "),_("td",[v._v("Java")]),v._v(" "),_("td",[v._v("Scala&Java")])]),v._v(" "),_("tr",[_("td",[v._v("协议支持")]),v._v(" "),_("td",[v._v("AMQP，XMPP，SMTP，STOMP")]),v._v(" "),_("td",[v._v("OpenWire,STOMP，REST,XMPP,AMQP")]),v._v(" "),_("td",[v._v("自定义协议")]),v._v(" "),_("td",[v._v("自定义协议")])]),v._v(" "),_("tr",[_("td",[v._v("可用性")]),v._v(" "),_("td",[v._v("高")]),v._v(" "),_("td",[v._v("一般")]),v._v(" "),_("td",[v._v("高")]),v._v(" "),_("td",[v._v("高")])]),v._v(" "),_("tr",[_("td",[v._v("单机吞吐量")]),v._v(" "),_("td",[v._v("一般")]),v._v(" "),_("td",[v._v("差")]),v._v(" "),_("td",[v._v("高")]),v._v(" "),_("td",[v._v("非常高")])]),v._v(" "),_("tr",[_("td",[v._v("消息延迟")]),v._v(" "),_("td",[v._v("微秒级")]),v._v(" "),_("td",[v._v("毫秒级")]),v._v(" "),_("td",[v._v("毫秒级")]),v._v(" "),_("td",[v._v("毫秒以内")])]),v._v(" "),_("tr",[_("td",[v._v("消息可靠性")]),v._v(" "),_("td",[v._v("高")]),v._v(" "),_("td",[v._v("一般")]),v._v(" "),_("td",[v._v("高")]),v._v(" "),_("td",[v._v("一般")])])])]),v._v(" "),_("p",[v._v("追求可用性：Kafka、 RocketMQ 、RabbitMQ")]),v._v(" "),_("p",[v._v("追求可靠性：RabbitMQ、RocketMQ")]),v._v(" "),_("p",[v._v("追求吞吐能力：RocketMQ、Kafka")]),v._v(" "),_("p",[v._v("追求消息低延迟：RabbitMQ、Kafka")]),v._v(" "),_("p",[v._v("据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。")])])}),[],!1,null,null,null);_.default=r.exports}}]);