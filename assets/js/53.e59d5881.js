(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{425:function(v,_,p){"use strict";p.r(_);var r=p(1),t=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"面试现场"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试现场"}},[v._v("#")]),v._v(" 面试现场")]),v._v(" "),_("h3",{attrs:{id:"jvm组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm组成"}},[v._v("#")]),v._v(" JVM组成")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("面试官")]),v._v("：JVM由那些部分组成，运行流程是什么？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，好的~~")]),v._v(" "),_("p",[v._v("在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）")]),v._v(" "),_("p",[v._v("它们的运行流程是：")]),v._v(" "),_("p",[v._v("第一，类加载器（ClassLoader）把Java代码转换为字节码")]),v._v(" "),_("p",[v._v("第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行")]),v._v(" "),_("p",[v._v("第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：好的，你能详细说一下 JVM 运行时数据区吗？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，好~")]),v._v(" "),_("p",[v._v("运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。")]),v._v(" "),_("ul",[_("li",[v._v("堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。")]),v._v(" "),_("li",[v._v("方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。")]),v._v(" "),_("li",[v._v("栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。")]),v._v(" "),_("li",[v._v("本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。")]),v._v(" "),_("li",[v._v("程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。")])]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：好的，你再详细介绍一下程序计数器的作用？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，是这样~~")]),v._v(" "),_("p",[v._v("java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：你能给我详细的介绍Java堆吗?")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("好的~")]),v._v(" "),_("p",[v._v("Java中的堆术语线程共享的区域。主要用来保存"),_("strong",[v._v("对象实例，数组")]),v._v("等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。")]),v._v(" "),_("p",[v._v("​        在JAVA8中堆内会存在年轻代、老年代")]),v._v(" "),_("p",[v._v("​        1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。")]),v._v(" "),_("p",[v._v("​        2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：能不能解释一下方法区？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("好的~")]),v._v(" "),_("p",[v._v("与虚拟机栈类似。本地方法栈是为虚拟机"),_("strong",[v._v("执行本地方法时提供服务的")]),v._v("。不需要进行GC。本地方法一般是由其他语言编写。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：你听过直接内存吗？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯~~")]),v._v(" "),_("p",[v._v("它又叫做"),_("strong",[v._v("堆外内存")]),v._v("，"),_("strong",[v._v("线程共享的区域")]),v._v("，在 Java 8 之前有个"),_("strong",[v._v("永久代")]),v._v("的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，"),_("strong",[v._v("主要存储类的信息，常量，静态变量")]),v._v("，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。")]),v._v(" "),_("p",[v._v("​        所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：什么是虚拟机栈")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建"),_("strong",[v._v("栈桢")]),v._v("。保存执行方法时的"),_("strong",[v._v("局部变量、动态连接信息、方法返回地址信息")]),v._v("等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域"),_("strong",[v._v("不需要进行 GC")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：能说一下堆栈的区别是什么吗？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，好的，有这几个区别")]),v._v(" "),_("p",[v._v("第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。")]),v._v(" "),_("p",[v._v("第二、栈内存是线程私有的，而堆内存是线程共有的。")]),v._v(" "),_("p",[v._v("第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。")]),v._v(" "),_("p",[v._v("栈空间不足：java.lang.StackOverFlowError。")]),v._v(" "),_("p",[v._v("堆空间不足：java.lang.OutOfMemoryError。")])]),v._v(" "),_("ol",[_("li",[_("h3",{attrs:{id:"类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[v._v("#")]),v._v(" 类加载器")])])]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("面试官")]),v._v("：什么是类加载器，类加载器有哪些?")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，是这样的")]),v._v(" "),_("p",[v._v("JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将"),_("strong",[v._v("字节码文件加载到JVM中")]),v._v("，从而让Java程序能够启动起来。")]),v._v(" "),_("p",[v._v("常见的类加载器有4个")]),v._v(" "),_("p",[v._v("第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。")]),v._v(" "),_("p",[v._v("第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。")]),v._v(" "),_("p",[v._v("第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。")]),v._v(" "),_("p",[v._v("第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：说一下类装载的执行过程？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，这个过程还是挺多的。")]),v._v(" "),_("p",[v._v("类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）")]),v._v(" "),_("p",[v._v("1.加载：查找和导入class文件")]),v._v(" "),_("p",[v._v("2.验证：保证加载类的准确性")]),v._v(" "),_("p",[v._v("3.准备：为类变量分配内存并设置类变量初始值")]),v._v(" "),_("p",[v._v("4.解析：把类中的符号引用转换为直接引用")]),v._v(" "),_("p",[v._v("5.初始化：对类的静态变量，静态代码块执行初始化操作")]),v._v(" "),_("p",[v._v("6.使用：JVM 开始从入口方法开始执行用户的程序代码")]),v._v(" "),_("p",[v._v("7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：什么是双亲委派模型？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，它是是这样的。")]),v._v(" "),_("p",[v._v("如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：JVM为什么采用双亲委派机制")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("主要有两个原因。")]),v._v(" "),_("p",[v._v("第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。")]),v._v(" "),_("p",[v._v("第二、为了安全，保证类库API不会被修改")])]),v._v(" "),_("h3",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("面试官")]),v._v("：简述Java垃圾回收机制？（GC是什么？为什么要GC）")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，是这样~~")]),v._v(" "),_("p",[v._v("为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。")]),v._v(" "),_("p",[v._v("有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。")]),v._v(" "),_("p",[v._v("在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：强引用、软引用、弱引用、虚引用的区别？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯嗯~")]),v._v(" "),_("p",[v._v("强引用最为普通的引用方式，表示一个对象处于"),_("strong",[v._v("有用且必须")]),v._v("的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收")]),v._v(" "),_("p",[v._v("软引用表示一个对象处于"),_("strong",[v._v("有用且非必须")]),v._v("状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。")]),v._v(" "),_("p",[v._v("弱引用表示一个对象处于"),_("strong",[v._v("可能有用且非必须")]),v._v("的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。")]),v._v(" "),_("p",[v._v("虚引用表示一个对象处于"),_("strong",[v._v("无用")]),v._v("的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：对象什么时候可以被垃圾器回收")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("思考一会~~")]),v._v(" "),_("p",[v._v("如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。")]),v._v(" "),_("p",[v._v("如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法")]),v._v(" "),_("p",[v._v("通常都使用可达性分析算法来确定是不是垃圾")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("： JVM 垃圾回收算法有哪些？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("： 你能详细聊一下分代回收吗？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("关于分代回收是这样的")]),v._v(" "),_("p",[v._v("在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2")]),v._v(" "),_("p",[v._v("对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1")]),v._v(" "),_("p",[v._v("具体的工作机制是有些情况：")]),v._v(" "),_("p",[v._v("1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。")]),v._v(" "),_("p",[v._v("2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且"),_("strong",[v._v("当前对象的年龄会加1")]),v._v("，清空Eden区。")]),v._v(" "),_("p",[v._v("3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。")]),v._v(" "),_("p",[v._v("4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。")]),v._v(" "),_("p",[v._v("5）对象的年龄达到了某一个限定的值（"),_("strong",[v._v("默认15岁")]),v._v("  ），那么这个对象就会进入到老年代中。")]),v._v(" "),_("p",[v._v("当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代")]),v._v(" "),_("p",[v._v("当老年代满了之后，"),_("strong",[v._v("触发FullGC")]),v._v("。"),_("strong",[v._v("FullGC同时回收新生代和老年代")]),v._v("，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：讲一下新生代、老年代、永久代的区别？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯！是这样的，简单说就是")]),v._v(" "),_("p",[_("strong",[v._v("新生代")]),v._v("主要用来存放新生的对象。")]),v._v(" "),_("p",[_("strong",[v._v("老年代")]),v._v("主要存放应用中生命周期长的内存对象。")]),v._v(" "),_("p",[_("strong",[v._v("永久代")]),v._v("指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（"),_("strong",[v._v("元空间")]),v._v("）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：说一下 JVM 有哪些垃圾回收器？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：Minor GC、Major GC、Full GC是什么")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，其实它们指的是不同代之间的垃圾回收")]),v._v(" "),_("p",[v._v("Minor GC 发生在新生代的垃圾回收，暂停时间短")]),v._v(" "),_("p",[v._v("Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长")]),v._v(" "),_("p",[v._v("Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，"),_("strong",[v._v("应尽力避免")])])]),v._v(" "),_("h3",{attrs:{id:"jvm实践-调优"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm实践-调优"}},[v._v("#")]),v._v(" JVM实践（调优）")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("面试官")]),v._v("：JVM 调优的参数可以在哪里设置参数值？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：用的 JVM 调优的参数都有哪些？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，这些参数是比较多的")]),v._v(" "),_("p",[v._v("我记得当时我们设置过堆的大小，像-Xms和-Xmx")]),v._v(" "),_("p",[v._v("还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例")]),v._v(" "),_("p",[v._v("还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：嗯，好的，你们平时调试 JVM都用了哪些工具呢？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，我们一般都是使用jdk自带的一些工具，比如")]),v._v(" "),_("p",[v._v("jps 输出JVM中运行的进程状态信息")]),v._v(" "),_("p",[v._v("jstack查看java进程内"),_("strong",[v._v("线程的堆栈")]),v._v("信息。")]),v._v(" "),_("p",[v._v("jmap 用于生成堆转存快照")]),v._v(" "),_("p",[v._v("jstat用于JVM统计监测工具")]),v._v(" "),_("p",[v._v("还有一些可视化工具，像jconsole和VisualVM等")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：假如项目中产生了java内存泄露，你说一下你的排查思路？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，这个我在之前项目排查过")]),v._v(" "),_("p",[v._v("第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件")]),v._v(" "),_("p",[v._v("第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析")]),v._v(" "),_("p",[v._v("第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题")]),v._v(" "),_("p",[v._v("第四，找到对应的代码，通过阅读上下文的情况，进行修复即可")]),v._v(" "),_("p",[_("strong",[v._v("面试官")]),v._v("：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？")]),v._v(" "),_("p",[_("strong",[v._v("候选人:")])]),v._v(" "),_("p",[v._v("嗯，我思考一下~~")]),v._v(" "),_("p",[v._v("可以这么做~~")]),v._v(" "),_("p",[v._v("第一可以使用使用top命令查看占用cpu的情况")]),v._v(" "),_("p",[v._v("第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id")]),v._v(" "),_("p",[v._v("第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高")]),v._v(" "),_("p",[v._v("第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号")])])])}),[],!1,null,null,null);_.default=t.exports}}]);