(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{420:function(v,_,e){"use strict";e.r(_);var a=e(1),o=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"谈谈你对threadlocal的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对threadlocal的理解"}},[v._v("#")]),v._v(" 谈谈你对ThreadLocal的理解")]),v._v(" "),_("p",[v._v("ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享，不同方法可以共享同一个 "),_("code",[v._v("ThreadLocal")]),v._v(" 变量。")]),v._v(" "),_("p",[v._v("底层原理")]),v._v(" "),_("h2",{attrs:{id:"threadlocal的底层原理实现吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal的底层原理实现吗"}},[v._v("#")]),v._v(" ThreadLocal的底层原理实现吗？")]),v._v(" "),_("p",[v._v("ThreadLocal其实是线程Thread类在内部维护了一个 ThreadLocalMap 类型的成员变量，用来存储资源对象")]),v._v(" "),_("p",[v._v("当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中")]),v._v(" "),_("p",[v._v("当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值")]),v._v(" "),_("p",[v._v("当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值")]),v._v(" "),_("h2",{attrs:{id:"threadlocal会导致内存溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal会导致内存溢出"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.bilibili.com/video/BV1FRdyYgEH9",target:"_blank",rel:"noopener noreferrer"}},[v._v("ThreadLocal会导致内存溢出"),_("OutboundLink")],1)]),v._v(" "),_("p",[v._v("ThreadLocal 如果使用不当，确实可能导致内存泄漏，核心原因是 "),_("strong",[v._v("ThreadLocalMap 的 key 是弱引用，而 value 是强引用")]),v._v("，加上线程复用（如线程池），无效的 Entry 无法被及时清理。")]),v._v(" "),_("p",[v._v("ThreadLocal 的数据存储在 线程的 ThreadLocalMap 中，key 是 ThreadLocal 对象本身， 它是弱引用，会被 GC 回收变为 null，但 Value 仍被 Entry 强引用，导致无法回收。")]),v._v(" "),_("p",[v._v("当线程一直存在不被清除时，比如线程池复用时，ThreadLocalMap 会一直存在")]),v._v(" "),_("p",[v._v("ThreadLocal有两种情况导致OOM：")]),v._v(" "),_("p",[v._v("当 ThreadLocal 是局部变量，用完被清除，失去强引用，key 因弱引用被 GC 回收变为null，而value会一直存在导致OOM。\n当ThreadLocal 是静态变量。虽然 key 不会被回收（静态变量是强引用），但如果线程复用时不调用 "),_("code",[v._v("remove()")]),v._v("，多次 "),_("code",[v._v("set()")]),v._v(" 会导致旧 value 无法释放（例如线程池任务中重复使用同一个 ThreadLocal）。")]),v._v(" "),_("p",[v._v("解决方法：")]),v._v(" "),_("p",[v._v("threadLocalMap有清除机制，会在调用set() / get() 时自动清除key为null的数据。\n但是使用ThreadLocal 时通常把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。")]),v._v(" "),_("p",[v._v("总：")]),v._v(" "),_("p",[v._v("不恰当使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 可能导致内存泄漏。主要原因在于其底层 "),_("code",[v._v("ThreadLocalMap")]),v._v(" 的 "),_("code",[v._v("key")]),v._v(" 是一个弱引用（"),_("code",[v._v("WeakReference")]),v._v("）。弱引用的特性是："),_("strong",[v._v("无论是否存在直接引用关系，只要 "),_("code",[v._v("ThreadLocal")]),v._v(" 实例没有其他强引用关联，垃圾回收（GC）时 "),_("code",[v._v("key")]),v._v(" 就会被回收")]),v._v("。从而导致 "),_("code",[v._v("key")]),v._v(" 变为 "),_("code",[v._v("null")]),v._v("，但 "),_("code",[v._v("value")]),v._v(" 仍被强引用关联，造成这块内存无法访问和回收，出现内存泄漏的问题")]),v._v(" "),_("p",[v._v("规避内存泄漏的两种方法：")]),v._v(" "),_("p",[_("strong",[v._v("扩大 "),_("code",[v._v("ThreadLocal")]),v._v(" 变量的作用域")]),v._v("（例如声明为 "),_("code",[v._v("static")]),v._v(" 或全局变量），避免 "),_("code",[v._v("ThreadLocal")]),v._v(" 实例被 GC 回收，不过若后续线程不再访问该 "),_("code",[v._v("key")]),v._v("，"),_("code",[v._v("value")]),v._v(" 仍会长期占用内存，最终可能导致内存溢出（OOM）。\n在数据使用完成后主动调用remove方法清除 "),_("code",[v._v("Entry")]),v._v("，这是在实际使用中最好的方式")]),v._v(" "),_("h2",{attrs:{id:"threadlocal有哪些使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal有哪些使用场景"}},[v._v("#")]),v._v(" ThreadLocal有哪些使用场景")]),v._v(" "),_("p",[v._v("ThreadLocal是一种多线程隔离机制，通过多线程环境下对共享变量的副本存储，解决了线程安全问题，避免了多线程竞争加锁的开销。其使用场景包括：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("线程的上下文传递")]),v._v(" "),_("ul",[_("li",[v._v("在处理请求的过程中保持用户特定的数据（如用户的登录信息）。通过 "),_("code",[v._v("ThreadLocal")]),v._v(" 可以方便地在同一个线程内的不同方法调用之间共享这些数据，而不用担心线程安全问题。")])])]),v._v(" "),_("li",[_("p",[v._v("数据库连接管理")]),v._v(" "),_("ul",[_("li",[v._v("在多线程应用中，每个线程可以使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 来独立管理自己的数据库连接，避免线程之间的竞争与冲突。如mybatis的sqlsession")])])]),v._v(" "),_("li",[_("p",[v._v("事务管理等")]),v._v(" "),_("ul",[_("li",[v._v("使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 可以让每个线程拥有独立的事务上下文，保证事务的隔离性。Spring 的 "),_("code",[v._v("TransactionSynchronizationManager")]),v._v(" 就使用 "),_("code",[v._v("ThreadLocal")]),v._v(" 来存储当前线程的事务资源（如数据库连接）。")])])])]),v._v(" "),_("p",[v._v("在使用ThreadLocall时，需要注意避免内存泄漏的问题。")]),v._v(" "),_("h2",{attrs:{id:"volatile关键字有什么用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#volatile关键字有什么用"}},[v._v("#")]),v._v(" volatile关键字有什么用")]),v._v(" "),_("p",[v._v("volatile关键字有两个作用\n可以保证多线程环境下，对共享变量的可见性，\n可以通过增加内存屏障，去防止多个指令之间的重排序，")]),v._v(" "),_("p",[v._v("可见性就是当一个线程对共享变量的修改，其他线程可以立刻看到修改之后的值，\n可见性问题，是在多线程环境下，每个线程都有自己的工作内存（缓存），线程操作变量时，可能会先读取缓存中的副本，而不是直接访问主内存。这可能导致一个线程修改了变量，但另一个线程看不到最新值。")]),v._v(" "),_("ul",[_("li",[v._v("当一个线程修改 "),_("code",[v._v("volatile")]),v._v(" 变量时，会"),_("strong",[v._v("立即将新值写回主内存")]),v._v("。")]),v._v(" "),_("li",[v._v("其他线程读取该变量时，会"),_("strong",[v._v("强制从主内存重新加载最新值")]),v._v("，而不是使用本地缓存。")])]),v._v(" "),_("p",[v._v("指令重排序就是指令在编写的顺序和执行顺序是不一致的，为了提高性能，JVM 和 CPU 可能会对指令进行"),_("strong",[v._v("重排序")]),v._v("（在不改变单线程执行结果的前提下）。但在多线程环境下，重排序可能导致"),_("strong",[v._v("线程安全问题")]),v._v("（如单例模式的双重检查锁失效）。")]),v._v(" "),_("ul",[_("li",[v._v("通过"),_("strong",[v._v("内存屏障（Memory Barrier）")]),v._v(" 禁止 JVM 对 "),_("code",[v._v("volatile")]),v._v(" 变量的读写操作进行重排序。")]),v._v(" "),_("li",[v._v("确保 "),_("code",[v._v("volatile")]),v._v(" 变量的"),_("strong",[v._v("写操作")]),v._v("一定在"),_("strong",[v._v("读操作")]),v._v("之前完成（"),_("code",[v._v("happens-before")]),v._v(" 原则）。")])]),v._v(" "),_("h2",{attrs:{id:"如何理解线程安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何理解线程安全"}},[v._v("#")]),v._v(" 如何理解线程安全")]),v._v(" "),_("p",[v._v("线程安全是指在多线程环境下，当多个线程同时访问共享资源时，程序能够正确、一致地工作。这要求对共享数据的访问必须是原子的、可见的和有序的。")]),v._v(" "),_("p",[v._v("原子性：一个线程访问共享资源时的操作不能被中断，如果被中断，可能会导致执行结果不一致的问题，CPU上下文切换是导致原子性问题的一个核心，jvm提供了synchronized关键字来解决原子性问题。\n可见性：一个线程对共享变量的修改能够及时被其他线程看到，导致可见性问题的问题有很多，比如像CPU的高速缓存、CPU的指令重排序、编译器的指令重排序\n有序性：程序编写的指令顺序和CPU最终运行的指令顺序可能不一致，这种现象称为指令重排序")]),v._v(" "),_("p",[v._v("可见性和有序性问题可以通过volatile关键字解决")]),v._v(" "),_("p",[v._v("实现线程安全的常见方法包括：使用同步机制、使用线程安全的数据结构。但是过度同步会影响性能，因此需要根据具体场景选择合适的线程安全策略")]),v._v(" "),_("h3",{attrs:{id:"保证线程安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#保证线程安全"}},[v._v("#")]),v._v(" 保证线程安全")]),v._v(" "),_("ul",[_("li",[v._v("在方法内使用，局部变量则是线程安全的")]),v._v(" "),_("li",[v._v("使用线程安全的ArrayList和LinkedList")])]),v._v(" "),_("h3",{attrs:{id:"simpledateformat-是线程安全的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#simpledateformat-是线程安全的吗"}},[v._v("#")]),v._v(" "),_("strong",[v._v("SimpleDateFormat")]),v._v(" 是线程安全的吗")]),v._v(" "),_("p",[_("code",[v._v("SimpleDateFormat")]),v._v(" 内部维护了一个 "),_("code",[v._v("Calendar")]),v._v(" 对象引用，用于存储和解析日期信息。当多个线程共享同一个 "),_("code",[v._v("SimpleDateFormat")]),v._v(" 实例时，会出现以下问题：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("共享 "),_("code",[v._v("Calendar")]),v._v(" 引用")]),v._v("：多个线程同时操作同一个 "),_("code",[v._v("Calendar")]),v._v(" 对象，导致数据竞争。")]),v._v(" "),_("li",[_("strong",[v._v("数据不一致")]),v._v("：可能引发日期解析错误、格式化异常，甚至程序崩溃。")])]),v._v(" "),_("p",[v._v("有四种方法可以解决这个问题\n第一种把SimpleDateFormat定义成一个局部变量，每个线程调用这个方法的时候，都创建一个新的实例，\n第二种我们可以使用ThreadLocal，把SimpleDateFormat变成一个线程私有的，\n第三种加一个同步锁，在同一个时刻，只允许一个线程去操作SimpleDateFormat，\n第四种，在java8里面呢引入了一些线程安全的日期API，比如说像localDataTimer，DateTimeFormatter等等")]),v._v(" "),_("h2",{attrs:{id:"什么是守护线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是守护线程"}},[v._v("#")]),v._v(" 什么是守护线程？")]),v._v(" "),_("p",[v._v("守护线程（Daemon Thread）是一种在后台运行的线程，它的生命周期依赖于非守护线程（即用户线程）。当所有的非守护线程结束时，JVM 会自动退出，并终止所有仍在运行的守护线程，即使它们还未完成任务")]),v._v(" "),_("p",[v._v("守护线程的创建方法和普通线程是一样的，只需要调用setDaemon方法设置参数为true就表示创建一个守护线程")]),v._v(" "),_("p",[v._v("守护线程通常用于执行非关键任务，如垃圾回收、日志记录等，这个场景的特点就是当jvm 的进程结束后，守护线程的本身就没有存在的 意义了，不能因为进行垃圾回收就阻止jvm进程无法结束。而守护线程不能用于线程池或者IO的一些任务场景，因为一旦jvm退出后，守护线程就会直接退出，导致任务还没有执行完成或者资源没有释放等问题。")]),v._v(" "),_("h2",{attrs:{id:"伪共享的概念以及如何避免"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#伪共享的概念以及如何避免"}},[v._v("#")]),v._v(" 伪共享的概念以及如何避免")]),v._v(" "),_("p",[v._v("由于CPU采用"),_("strong",[v._v("缓存行（Cache Line，64字节）"),_("strong",[v._v("加载数据（基于空间局部性原理），若多个线程修改")]),v._v("同一缓存行中的不同变量")]),v._v("（如变量X和Y），会触发"),_("strong",[v._v("缓存一致性协议（如MESI）")]),v._v("，导致其他CPU的缓存行失效，这种不必要的竞争称为伪共享，会显著降低并发性能。")]),v._v(" "),_("p",[v._v("解决办法有两个")]),v._v(" "),_("ol",[_("li",[v._v("使用对齐填充，读取的目标数据，小于64个字节时，可以增加一些无意义的成员变量来填充到64个字节，")]),v._v(" "),_("li",[v._v("在java8提供了@Contented的注解，被@Contented的注解标记的类或者字段，JVM会自动填充缓存行")])]),v._v(" "),_("h2",{attrs:{id:"dcl单例模式为什么需要volatile关键字修饰"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dcl单例模式为什么需要volatile关键字修饰"}},[v._v("#")]),v._v(" DCL单例模式为什么需要volatile关键字修饰")]),v._v(" "),_("p",[v._v("DCL单例模式（Double-Checked Locking）通过双重检验机制实现线程安全的延迟初始化：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("第一次检查")]),v._v("：判断 "),_("code",[v._v("instance")]),v._v(" 是否已初始化（避免已初始化时进入同步块，提升性能）。")]),v._v(" "),_("li",[_("strong",[v._v("同步锁")]),v._v("：若未初始化，通过 "),_("code",[v._v("synchronized")]),v._v(" 防止多线程并发创建实例。")]),v._v(" "),_("li",[_("strong",[v._v("第二次检查")]),v._v("：在同步块内再次检查 "),_("code",[v._v("instance")]),v._v("（防止首次初始化时多个线程通过第一次检查后的重复创建）。")])]),v._v(" "),_("p",[v._v("通过第二次检查的进程会执行 "),_("code",[v._v("instance = new Singleton()")]),v._v(" 的初始化操作")]),v._v(" "),_("p",[v._v("但这个操作并非原子操作，实际会被JVM拆分为以下三条指令：")]),v._v(" "),_("ol",[_("li",[v._v("分配对象内存空间")]),v._v(" "),_("li",[v._v("初始化对象（调用构造函数）")]),v._v(" "),_("li",[v._v("将引用赋值给 "),_("code",[v._v("instance")])])]),v._v(" "),_("p",[v._v("由于指令重排序（JVM优化），可能导致步骤3先于步骤2执行。此时若其他线程访问 "),_("code",[v._v("instance")]),v._v("，会获取到未初始化的对象（非 "),_("code",[v._v("null")]),v._v(" 但状态不一致）。")]),v._v(" "),_("p",[v._v("所以需要使用volatile关键字修饰instance变量，volatile会在底层使用了一个内存屏障机制，来去避免指令重排序，并强制线程每次访问 "),_("code",[v._v("instance")]),v._v(" 时从主内存读取最新值。")]),v._v(" "),_("h2",{attrs:{id:"请你说一下对happens-before的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请你说一下对happens-before的理解"}},[v._v("#")]),v._v(" 请你说一下对Happens-Before的理解")]),v._v(" "),_("p",[_("strong",[v._v("Happens-Before")]),v._v(" 是 Java 内存模型（JMM）提供的一种"),_("strong",[v._v("内存可见性保证")]),v._v("机制。在多线程环境下，由于"),_("strong",[v._v("指令重排序")]),v._v("和"),_("strong",[v._v("CPU缓存一致性")]),v._v("问题，可能导致一个线程对共享变量的修改对另一个线程不可见。JMM 通过 "),_("strong",[v._v("Happens-Before")]),v._v(" 关系，向开发者提供了一种跨线程的"),_("strong",[v._v("内存可见性约束")]),v._v("，确保某些操作的执行结果对其他操作可见。")]),v._v(" "),_("p",[_("strong",[v._v("Happens-Before 的核心概念：")])]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("可见性保证")]),v._v("：如果操作 A "),_("strong",[v._v("Happens-Before")]),v._v(" 操作 B，那么 A 的执行结果对 B 可见。")]),v._v(" "),_("li",[_("strong",[v._v("不约束执行顺序")]),v._v("：Happens-Before 仅规定"),_("strong",[v._v("可见性")]),v._v("，并不强制要求指令的实际执行顺序。只要不影响最终结果，JVM 仍然可以优化指令顺序。")])]),v._v(" "),_("p",[v._v("JMM中存在的happy before规则，")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("程序顺序规则")]),v._v("：同一线程中的每个操作 happens-before 于该线程中任意后续操作，也就i是不管怎么改变，单线程的执行结果不能改变。")]),v._v(" "),_("li",[_("strong",[v._v("传递性")]),v._v("：如果 A happens-before B，且 B happens-before C，那么 A happens-before C")]),v._v(" "),_("li",[_("strong",[v._v("volatile变量规则")]),v._v("：对一个 volatile 变量的写操作 happens-before 于任意后续对这个 volatile 变量的读操作")]),v._v(" "),_("li",[_("strong",[v._v("监视器锁规则")]),v._v("：对一个锁的解锁 happens-before 于后续对这个锁的加锁操作")]),v._v(" "),_("li",[_("strong",[v._v("线程启动规则")]),v._v("：线程 A 启动线程 B，那么线程 A 启动 B 之前的操作 happens-before 于线程 B 中的任意操作")]),v._v(" "),_("li",[_("strong",[v._v("线程终止规则")]),v._v("：线程 A 中的任何操作都 happens-before 于其他 检测到线程 A 已经终止的 线程")])])])}),[],!1,null,null,null);_.default=o.exports}}]);