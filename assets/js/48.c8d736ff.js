(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{416:function(v,_,a){"use strict";a.r(_);var t=a(0),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"类的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期"}},[v._v("#")]),v._v(" 类的生命周期")]),v._v(" "),_("p",[v._v("加载")]),v._v(" "),_("p",[v._v("验证")]),v._v(" "),_("p",[v._v("准备：给静态变量默认值、static final初始值、")]),v._v(" "),_("p",[v._v("解析")]),v._v(" "),_("p",[v._v("初始化")]),v._v(" "),_("p",[v._v("使用")]),v._v(" "),_("p",[v._v("销毁")]),v._v(" "),_("h2",{attrs:{id:"什么是类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是类加载器"}},[v._v("#")]),v._v(" 什么是类加载器")]),v._v(" "),_("p",[v._v("类加载器（ClassLoader）的主要作用就是将"),_("strong",[v._v("字节码文件加载到JVM中")]),v._v("，从而让Java程序能够启动起来。")]),v._v(" "),_("p",[v._v("启动类加载器（C++编写、jdk9后java）用于加载"),_("strong",[v._v("JAVA_HOME/jre/lib")]),v._v("目录下的类库。")]),v._v(" "),_("p",[v._v("扩展类加载器、平台类加载器（jdk9）加载"),_("strong",[v._v("JAVA_HOME/jre/lib/ext")]),v._v("目录中的类库。")]),v._v(" "),_("p",[v._v("应用程序类加载器：主要用于加载"),_("strong",[v._v("classPath")]),v._v("下的类，也就是加载开发者自己编写的Java类。")]),v._v(" "),_("p",[v._v("自定义类加载器：重写findclass方法")]),v._v(" "),_("h2",{attrs:{id:"什么是双亲委派机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是双亲委派机制"}},[v._v("#")]),v._v(" 什么是双亲委派机制")]),v._v(" "),_("p",[v._v("每一个类加载器都有一个父类加载器，形成一个层级结构")]),v._v(" "),_("p",[v._v("当一个类加载器接收到加载类的任务后，会查找这个类是否被加载过，没有则向上投递，直到启动类加载器，这个就是向上查找的过程，")]),v._v(" "),_("p",[v._v("如果启动类加载器也没有加载过，就检查该类是否在自己的加载路径上，没有则向下投递给下一个加载器加载，这个就是向下加载。这两个过程就是双亲委派机制，如果没有加载器能够加载，就抛出ClassNotFoundException")]),v._v(" "),_("h3",{attrs:{id:"双亲委派机制的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制的作用"}},[v._v("#")]),v._v(" 双亲委派机制的作用")]),v._v(" "),_("p",[v._v("​\t保证类加载的安全，如果要加载一个同名的String类，都会交给启动类加载，发现被加载过了就不会再加载，保证类库API不会被修改")]),v._v(" "),_("p",[v._v("​\t避免类的重复加载，保证唯一性。")]),v._v(" "),_("h2",{attrs:{id:"打破双亲委派机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#打破双亲委派机制"}},[v._v("#")]),v._v(" 打破双亲委派机制")]),v._v(" "),_("p",[v._v("打破双亲委派机制唯一方法是自定义类加载器中重写loadClass方法")]),v._v(" "),_("h2",{attrs:{id:"说一下类装载的执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下类装载的执行过程"}},[v._v("#")]),v._v(" 说一下类装载的执行过程")]),v._v(" "),_("p",[v._v("类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。")]),v._v(" "),_("p",[v._v("1.加载")]),v._v(" "),_("ul",[_("li",[v._v("通过类的全名，获取类的二进制数据流。")]),v._v(" "),_("li",[v._v("解析类的二进制数据流为方法区内的数据结构（Java类模型）")])]),v._v(" "),_("p",[v._v("2.验证")]),v._v(" "),_("p",[v._v("(1)文件格式验证：是否符合Class文件的规范")]),v._v(" "),_("p",[v._v("(2)元数据验证")]),v._v(" "),_("p",[v._v("​        这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）")]),v._v(" "),_("p",[v._v("​        这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）")]),v._v(" "),_("p",[v._v("​        类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）")]),v._v(" "),_("p",[v._v("(3)字节码验证")]),v._v(" "),_("p",[v._v("​        主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。")]),v._v(" "),_("p",[v._v("(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量")]),v._v(" "),_("p",[v._v("3.准备")]),v._v(" "),_("ul",[_("li",[v._v("static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成")]),v._v(" "),_("li",[v._v("static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成")]),v._v(" "),_("li",[v._v("static变量是final的引用类型，那么赋值也会在初始化阶段完成")])]),v._v(" "),_("p",[v._v("4.解析")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("把类中的符号引用转换为直接引用")])])]),v._v(" "),_("p",[v._v("5.初始化")]),v._v(" "),_("p",[_("strong",[v._v("对类的静态变量，静态代码块执行初始化操作")])]),v._v(" "),_("ul",[_("li",[v._v("如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。")]),v._v(" "),_("li",[v._v("如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。")])]),v._v(" "),_("p",[v._v("6.使用")]),v._v(" "),_("p",[v._v("JVM 开始从入口方法开始执行用户的程序代码")]),v._v(" "),_("ul",[_("li",[v._v("调用静态类成员信息（比如：静态字段、静态方法）")]),v._v(" "),_("li",[v._v("使用new关键字为其创建对象实例")])]),v._v(" "),_("p",[v._v("7.卸载")]),v._v(" "),_("p",[v._v("当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存")])])}),[],!1,null,null,null);_.default=s.exports}}]);