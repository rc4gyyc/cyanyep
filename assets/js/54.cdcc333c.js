(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{417:function(_,v,e){"use strict";e.r(v);var a=e(0),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-spring框架中的单例bean是线程安全的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring框架中的单例bean是线程安全的吗"}},[_._v("#")]),_._v(" 1. Spring框架中的单例bean是线程安全的吗？")]),_._v(" "),v("p",[_._v("不是线程安全的。当多用户同时请求一个服务时，容器会给每个请求分配一个线程，这些线程会并发执行业务逻辑。如果处理逻辑中包含对单例状态的修改，比如修改单例的成员属性，就必须考虑线程同步问题。Spring框架本身并不对单例bean进行线程安全封装，线程安全和并发问题需要开发者自行处理。")]),_._v(" "),v("p",[_._v("通常在项目中使用的Spring bean是不可变状态（如Service类和DAO类），因此在某种程度上可以说Spring的单例bean是线程安全的。如果bean有多种状态（如View Model对象），就需要自行保证线程安全。最简单的解决办法是将单例bean的作用域由“singleton”变更为“prototype”。")]),_._v(" "),v("h2",{attrs:{id:"_2-什么是aop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是aop"}},[_._v("#")]),_._v(" 2. 什么是AOP？")]),_._v(" "),v("p",[_._v("AOP，即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。常见的应用场景包括公共日志保存和事务处理。")]),_._v(" "),v("h3",{attrs:{id:"_3-你们项目中有没有使用到aop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-你们项目中有没有使用到aop"}},[_._v("#")]),_._v(" 3. 你们项目中有没有使用到AOP？")]),_._v(" "),v("p",[_._v("我们之前在后台管理系统中使用AOP来记录系统操作日志。主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。")]),_._v(" "),v("h3",{attrs:{id:"_4-spring中的事务是如何实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-spring中的事务是如何实现的"}},[_._v("#")]),_._v(" 4. Spring中的事务是如何实现的？")]),_._v(" "),v("p",[_._v("Spring实现事务的本质是利用AOP完成的。它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。")]),_._v(" "),v("h3",{attrs:{id:"_5-spring中事务失效的场景有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-spring中事务失效的场景有哪些"}},[_._v("#")]),_._v(" 5. Spring中事务失效的场景有哪些？")]),_._v(" "),v("p",[_._v("在项目中，我遇到过几种导致事务失效的场景：")]),_._v(" "),v("ol",[v("li",[_._v("如果方法内部捕获并处理了异常，没有将异常抛出，会导致事务失效。因此，处理异常后应该确保异常能够被抛出。")]),_._v(" "),v("li",[_._v("如果方法抛出非RuntimeException/Error，即检查型异常（checked exception），并且没有在"),v("code",[_._v("@Transactional")]),_._v("注解上配置"),v("code",[_._v("rollbackFor")]),_._v("属性为"),v("code",[_._v("Exception")]),_._v("，那么异常发生时事务可能不会回滚。")]),_._v(" "),v("li",[_._v("如果事务注解的方法不是公开（public）修饰的，也可能导致事务失效。")]),_._v(" "),v("li",[_._v("自调用：如果在类内部方法直接调用带@Transaction的方法，会绕过AOP代理，导致事务失效")])]),_._v(" "),v("h2",{attrs:{id:"_6-spring的bean的生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-spring的bean的生命周期"}},[_._v("#")]),_._v(" 6. Spring的bean的生命周期？")]),_._v(" "),v("p",[_._v("Spring中bean的生命周期包括以下步骤：")]),_._v(" "),v("ol",[v("li",[_._v("通过"),v("code",[_._v("BeanDefinition")]),_._v("获取bean的定义信息。")]),_._v(" "),v("li",[_._v("调用构造函数实例化bean。")]),_._v(" "),v("li",[_._v("进行bean的依赖注入，例如通过setter方法或"),v("code",[_._v("@Autowired")]),_._v("注解。")]),_._v(" "),v("li",[_._v("处理实现了"),v("code",[_._v("Aware")]),_._v("接口的bean。")]),_._v(" "),v("li",[_._v("执行"),v("code",[_._v("BeanPostProcessor")]),_._v("的前置处理器。")]),_._v(" "),v("li",[_._v("调用初始化方法，如实现了"),v("code",[_._v("InitializingBean")]),_._v("接口或自定义的"),v("code",[_._v("init-method")]),_._v("。")]),_._v(" "),v("li",[_._v("执行"),v("code",[_._v("BeanPostProcessor")]),_._v("的后置处理器，可能在这里产生代理对象。")]),_._v(" "),v("li",[_._v("最后是销毁bean。")])]),_._v(" "),v("h2",{attrs:{id:"_7-spring中的循环引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-spring中的循环引用"}},[_._v("#")]),_._v(" 7. Spring中的循环引用？")]),_._v(" "),v("p",[_._v("循环依赖发生在两个或两个以上的bean互相持有对方，形成闭环。Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题：")]),_._v(" "),v("ol",[v("li",[_._v("一级缓存：单例池，缓存已完成初始化的bean对象。")]),_._v(" "),v("li",[_._v("二级缓存：缓存尚未完成生命周期的早期bean对象。")]),_._v(" "),v("li",[_._v("三级缓存：缓存"),v("code",[_._v("ObjectFactory")]),_._v("，用于创建bean对象。")])]),_._v(" "),v("h2",{attrs:{id:"_8-那具体解决流程清楚吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-那具体解决流程清楚吗"}},[_._v("#")]),_._v(" 8. 那具体解决流程清楚吗？")]),_._v(" "),v("p",[_._v("解决循环依赖的流程如下：")]),_._v(" "),v("ol",[v("li",[_._v("实例化A对象，并创建"),v("code",[_._v("ObjectFactory")]),_._v("存入三级缓存。")]),_._v(" "),v("li",[_._v("A在初始化时需要B对象，开始B的创建逻辑。")]),_._v(" "),v("li",[_._v("B实例化完成，也创建"),v("code",[_._v("ObjectFactory")]),_._v("存入三级缓存。")]),_._v(" "),v("li",[_._v("B需要注入A，通过三级缓存获取"),v("code",[_._v("ObjectFactory")]),_._v("生成A对象，存入二级缓存。")]),_._v(" "),v("li",[_._v("B通过二级缓存获得A对象后，B创建成功，存入一级缓存。")]),_._v(" "),v("li",[_._v("A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。")]),_._v(" "),v("li",[_._v("清除二级缓存中的临时对象A。")])]),_._v(" "),v("h2",{attrs:{id:"_9-构造方法出现了循环依赖怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-构造方法出现了循环依赖怎么解决"}},[_._v("#")]),_._v(" 9. 构造方法出现了循环依赖怎么解决？")]),_._v(" "),v("p",[_._v("由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。可以使用"),v("code",[_._v("@Lazy")]),_._v("懒加载注解，延迟bean的创建直到实际需要时。")]),_._v(" "),v("h2",{attrs:{id:"_10-springmvc的执行流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-springmvc的执行流程"}},[_._v("#")]),_._v(" 10. SpringMVC的执行流程？")]),_._v(" "),v("p",[_._v("SpringMVC的执行流程包括以下步骤：")]),_._v(" "),v("ol",[v("li",[_._v("用户发送请求到前端控制器"),v("code",[_._v("DispatcherServlet")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("Dispatcher``Servlet")]),_._v("调用"),v("code",[_._v("HandlerMapping")]),_._v("找到具体处理器。")]),_._v(" "),v("li",[v("code",[_._v("HandlerMapping")]),_._v("返回处理器对象及拦截器（如果有）给"),v("code",[_._v("DispatcherServlet")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("DispatcherServlet")]),_._v("调用"),v("code",[_._v("HandlerAdapter")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("HandlerAdapter")]),_._v("适配并调用具体处理器（Controller）。")]),_._v(" "),v("li",[_._v("Controller执行并返回"),v("code",[_._v("ModelAndView")]),_._v("对象。")]),_._v(" "),v("li",[v("code",[_._v("HandlerAdapter")]),_._v("将"),v("code",[_._v("ModelAndView")]),_._v("返回给"),v("code",[_._v("DispatcherServlet")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("DispatcherServlet")]),_._v("传给"),v("code",[_._v("ViewResolver")]),_._v("进行视图解析。")]),_._v(" "),v("li",[v("code",[_._v("ViewResolver")]),_._v("返回具体视图给"),v("code",[_._v("DispatcherServlet")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("DispatcherServlet")]),_._v("渲染视图并响应用户。")])]),_._v(" "),v("h2",{attrs:{id:"_11-springboot自动配置原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-springboot自动配置原理"}},[_._v("#")]),_._v(" 11. Springboot自动配置原理？")]),_._v(" "),v("p",[_._v("Spring Boot的自动配置原理基于"),v("code",[_._v("@SpringBootApplication")]),_._v("注解，它封装了"),v("code",[_._v("@SpringBootConfiguration")]),_._v("、"),v("code",[_._v("@EnableAutoConfiguration")]),_._v("和"),v("code",[_._v("@ComponentScan")]),_._v("。"),v("code",[_._v("@EnableAutoConfiguration")]),_._v("是核心，它通过"),v("code",[_._v("@Import")]),_._v("导入配置选择器，读取"),v("code",[_._v("META-INF/spring.factories")]),_._v("文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。")]),_._v(" "),v("h2",{attrs:{id:"_12-spring-的常见注解有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-spring-的常见注解有哪些"}},[_._v("#")]),_._v(" 12. Spring 的常见注解有哪些？")]),_._v(" "),v("p",[_._v("Spring的常见注解包括：")]),_._v(" "),v("ol",[v("li",[_._v("声明Bean的注解："),v("code",[_._v("@Component")]),_._v("、"),v("code",[_._v("@Service")]),_._v("、"),v("code",[_._v("@Repository")]),_._v("、"),v("code",[_._v("@Controller")]),_._v("。")]),_._v(" "),v("li",[_._v("依赖注入相关注解："),v("code",[_._v("@Autowired")]),_._v("、"),v("code",[_._v("@``Qualifier")]),_._v("、"),v("code",[_._v("@Resource")]),_._v("。")]),_._v(" "),v("li",[_._v("设置作用域的注解："),v("code",[_._v("@Scope")]),_._v("。")]),_._v(" "),v("li",[_._v("配置相关注解："),v("code",[_._v("@Configuration")]),_._v("、"),v("code",[_._v("@ComponentScan")]),_._v("、"),v("code",[_._v("@Bean")]),_._v("。")]),_._v(" "),v("li",[_._v("AOP相关注解："),v("code",[_._v("@Aspect")]),_._v("、"),v("code",[_._v("@Before")]),_._v("、"),v("code",[_._v("@After")]),_._v("、"),v("code",[_._v("@Around")]),_._v("、"),v("code",[_._v("@Pointcut")]),_._v("。")])]),_._v(" "),v("h2",{attrs:{id:"_13-springmvc常见的注解有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-springmvc常见的注解有哪些"}},[_._v("#")]),_._v(" 13. SpringMVC常见的注解有哪些？")]),_._v(" "),v("p",[_._v("SpringMVC的常见注解有：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("@RequestMapping")]),_._v("：映射请求路径。")]),_._v(" "),v("li",[v("code",[_._v("@RequestBody")]),_._v("：接收HTTP请求的JSON数据。")]),_._v(" "),v("li",[v("code",[_._v("@RequestParam")]),_._v("：指定请求参数名称。")]),_._v(" "),v("li",[v("code",[_._v("@PathVariable")]),_._v("：从请求路径中获取参数。")]),_._v(" "),v("li",[v("code",[_._v("@ResponseBody")]),_._v("：将Controller方法返回的对象转化为JSON。")]),_._v(" "),v("li",[v("code",[_._v("@RequestHeader")]),_._v("：获取请求头数据。")]),_._v(" "),v("li",[v("code",[_._v("@PostMapping")]),_._v("、"),v("code",[_._v("@GetMapping")]),_._v("等。")])]),_._v(" "),v("h2",{attrs:{id:"_14-springboot常见注解有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-springboot常见注解有哪些"}},[_._v("#")]),_._v(" 14. Springboot常见注解有哪些？")]),_._v(" "),v("p",[_._v("Spring Boot的常见注解包括：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("@SpringBootApplication")]),_._v("：由"),v("code",[_._v("@SpringBootConfiguration")]),_._v("、"),v("code",[_._v("@EnableAutoConfiguration")]),_._v("和"),v("code",[_._v("@ComponentScan")]),_._v("组成。")]),_._v(" "),v("li",[_._v("其他注解如"),v("code",[_._v("@RestController")]),_._v("、"),v("code",[_._v("@GetMapping")]),_._v("、"),v("code",[_._v("@PostMapping")]),_._v("等，用于简化Spring MVC的配置。")])]),_._v(" "),v("h2",{attrs:{id:"_15-mybatis执行流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-mybatis执行流程"}},[_._v("#")]),_._v(" 15. MyBatis执行流程？")]),_._v(" "),v("p",[_._v("MyBatis的执行流程如下：")]),_._v(" "),v("ol",[v("li",[_._v("读取MyBatis配置文件"),v("code",[_._v("mybatis-config.xml")]),_._v("。")]),_._v(" "),v("li",[_._v("构造会话工厂"),v("code",[_._v("SqlSessionFactory")]),_._v("。")]),_._v(" "),v("li",[_._v("会话工厂创建"),v("code",[_._v("SqlSession")]),_._v("对象。")]),_._v(" "),v("li",[_._v("操作数据库的接口，"),v("code",[_._v("Executor")]),_._v("执行器。")]),_._v(" "),v("li",[v("code",[_._v("Executor")]),_._v("执行方法中的"),v("code",[_._v("MappedStatement")]),_._v("参数。")]),_._v(" "),v("li",[_._v("输入参数映射。")]),_._v(" "),v("li",[_._v("输出结果映射。")])]),_._v(" "),v("h2",{attrs:{id:"_16-mybatis是否支持延迟加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-mybatis是否支持延迟加载"}},[_._v("#")]),_._v(" 16. Mybatis是否支持延迟加载？")]),_._v(" "),v("p",[_._v("MyBatis支持延迟加载，即在需要用到数据时才加载。可以通过配置文件中的"),v("code",[_._v("lazyLoadingEnabled")]),_._v("配置启用或禁用延迟加载。")]),_._v(" "),v("h2",{attrs:{id:"_17-延迟加载的底层原理知道吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-延迟加载的底层原理知道吗"}},[_._v("#")]),_._v(" 17. 延迟加载的底层原理知道吗？")]),_._v(" "),v("p",[_._v("延迟加载的底层原理主要使用CGLIB动态代理实现：")]),_._v(" "),v("ol",[v("li",[_._v("使用CGLIB创建目标对象的代理对象。")]),_._v(" "),v("li",[_._v("调用目标方法时，如果发现是null值，则执行SQL查询。")]),_._v(" "),v("li",[_._v("获取数据后，设置属性值并继续查询目标方法。")])]),_._v(" "),v("h2",{attrs:{id:"_18-mybatis的一级、二级缓存用过吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-mybatis的一级、二级缓存用过吗"}},[_._v("#")]),_._v(" 18. Mybatis的一级、二级缓存用过吗？")]),_._v(" "),v("p",[_._v("MyBatis的一级缓存是基于"),v("code",[_._v("Perpetual``Cache")]),_._v("的HashMap本地缓存，作用域为Session，默认开启。二级缓存需要单独开启，作用域为Namespace或mapper，默认也是采用"),v("code",[_._v("PerpetualCache")]),_._v("，HashMap存储。")]),_._v(" "),v("h2",{attrs:{id:"_19-mybatis的二级缓存什么时候会清理缓存中的数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-mybatis的二级缓存什么时候会清理缓存中的数据"}},[_._v("#")]),_._v(" 19. Mybatis的二级缓存什么时候会清理缓存中的数据？")]),_._v(" "),v("p",[_._v("当作用域（一级缓存Session/二级缓存Namespaces）进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被清空。")]),_._v(" "),v("h2",{attrs:{id:"推荐使用构造函数注入"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#推荐使用构造函数注入"}},[_._v("#")]),_._v(" 推荐使用构造函数注入")]),_._v(" "),v("p",[_._v("依赖注入的三种方式")]),_._v(" "),v("ol",[v("li",[_._v("使用"),v("code",[_._v("@Autowired")]),_._v("注解：将"),v("code",[_._v("@Autowired")]),_._v("注解直接标记在字段上，Spring会自动注入依赖。")]),_._v(" "),v("li",[_._v("Setter注入：使用"),v("code",[_._v("@Autowired")]),_._v("注解标记Setter方法，Spring会自动调用Setter方法注入依赖。")]),_._v(" "),v("li",[_._v("构造函数注入：如果有构造函数，Spring会自动调用构造函数并注入所需的依赖。")])]),_._v(" "),v("p",[_._v("为什么推荐使用构造函数注入？")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("不可变性（Immutability）")]),_._v(" "),v("ul",[v("li",[_._v("构造函数注入允许将依赖字段声明为"),v("code",[_._v("final")]),_._v("，确保依赖在对象创建后不可变。")])])]),_._v(" "),v("li",[v("p",[_._v("确保依赖项不为null")]),_._v(" "),v("p",[_._v("构造函数注入强制要求在创建对象时提供所有依赖，如果依赖项不存在，编译器会报错")])]),_._v(" "),v("li",[v("p",[_._v("避免循环依赖")]),_._v(" "),v("p",[_._v("构造函数注入可以帮助发现循环依赖问题，因为Spring在启动时会检查构造函数注入的循环依赖。可以通过 "),v("code",[_._v("@Lazy")]),_._v("解决")])]),_._v(" "),v("li",[v("p",[_._v("符合单一职责原则")]),_._v(" "),v("p",[_._v("构造函数注入强制要求类的依赖在构造函数中明确声明，有助于遵循单一职责原则（SRP）。")])])]),_._v(" "),v("p",[_._v("使用构造函数时，当一个类只有一个构造函数时，Spring 会自动选择它进行注入，无需额外注解。如果有多个构造函数，需要使用 "),v("code",[_._v("@Autowired")]),_._v(" 或 "),v("code",[_._v("@Primary")]),_._v(" 明确指定。")]),_._v(" "),v("p",[_._v("如果需要添加注入的依赖，还需要修改构造函数，这时可以使用lombok工具的RequiredArgsConstructor，会自动注入被final修饰的字段")]),_._v(" "),v("h3",{attrs:{id:"spring通知有哪些类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring通知有哪些类型"}},[_._v("#")]),_._v(" Spring通知有哪些类型？")]),_._v(" "),v("h3",{attrs:{id:"解释基于xml-schema方式的切面实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解释基于xml-schema方式的切面实现"}},[_._v("#")]),_._v(" 解释基于XML Schema方式的切面实现")]),_._v(" "),v("h3",{attrs:{id:"解释基于注解的切面实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解释基于注解的切面实现"}},[_._v("#")]),_._v(" 解释基于注解的切面实现")]),_._v(" "),v("h3",{attrs:{id:"spring-aop的动态代理jdk和cglib的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop的动态代理jdk和cglib的区别"}},[_._v("#")]),_._v(" Spring AOP的动态代理JDK和CGLIB的区别")]),_._v(" "),v("p",[_._v("Spring AOP使用的动态代理，它基于动态代理来实现。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。（面试题）：\n/class com.sun.proxy.$Proxy19\n是jdk代理所产生的一个动态代理类，当被代理的类实现了接口会默认使用jdk代理\n实现了接口的bean不能用实现类的class对象来获取bean，只能通过其接口的class对象来获取bean（因为实现类不在IOC容器中，被代理拦截了，代理了实现类的代理放在IOC容器中，该代理和实现类实现了共同接口）或者实现类名字（需要用接口接收）")]),_._v(" "),v("p",[_._v('IUserService bean = ioc.getBean(IUserService.class):\nIUserService bean = (IUserService) ioc.getBean("userServiceImpl")；')]),_._v(" "),v("p",[_._v("//class cn.tulingxueyuan.service.impl.UserServiceImplSSEnhancerBySpringCGLIBS8f281cf64")]),_._v(" "),v("p",[_._v("cgIib代理所所产生的一个动态代理类，当被代理的类"),v("strong",[_._v("没有实现接口就会使用cglib代理")])]),_._v(" "),v("h3",{attrs:{id:"spring事务的实现方式和实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring事务的实现方式和实现原理"}},[_._v("#")]),_._v(" Spring事务的实现方式和实现原理")]),_._v(" "),v("h3",{attrs:{id:"spring的事务传播行为"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务传播行为"}},[_._v("#")]),_._v(" Spring的事务传播行为")]),_._v(" "),v("h3",{attrs:{id:"spring的事务隔离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务隔离"}},[_._v("#")]),_._v(" spring的事务隔离？")]),_._v(" "),v("h3",{attrs:{id:"spring框架的事务管理有哪些优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring框架的事务管理有哪些优点"}},[_._v("#")]),_._v(" Spring框架的事务管理有哪些优点？")])])}),[],!1,null,null,null);v.default=r.exports}}]);